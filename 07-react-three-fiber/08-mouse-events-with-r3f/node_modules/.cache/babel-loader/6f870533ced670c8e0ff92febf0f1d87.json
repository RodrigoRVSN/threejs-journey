{"ast":null,"code":"import { Mesh, PlaneGeometry, MeshBasicMaterial, CanvasTexture, sRGBEncoding, LinearFilter, Color } from 'three';\n\nclass HTMLMesh extends Mesh {\n  constructor(dom) {\n    const texture = new HTMLTexture(dom);\n    const geometry = new PlaneGeometry(texture.image.width * 0.001, texture.image.height * 0.001);\n    const material = new MeshBasicMaterial({\n      map: texture,\n      toneMapped: false,\n      transparent: true\n    });\n    super(geometry, material);\n\n    function onEvent(event) {\n      material.map.dispatchDOMEvent(event);\n    }\n\n    this.addEventListener('mousedown', onEvent);\n    this.addEventListener('mousemove', onEvent);\n    this.addEventListener('mouseup', onEvent);\n    this.addEventListener('click', onEvent);\n\n    this.dispose = function () {\n      geometry.dispose();\n      material.dispose();\n      material.map.dispose();\n      canvases.delete(dom);\n      this.removeEventListener('mousedown', onEvent);\n      this.removeEventListener('mousemove', onEvent);\n      this.removeEventListener('mouseup', onEvent);\n      this.removeEventListener('click', onEvent);\n    };\n  }\n\n}\n\nclass HTMLTexture extends CanvasTexture {\n  constructor(dom) {\n    super(html2canvas(dom));\n    this.dom = dom;\n    this.anisotropy = 16;\n    this.encoding = sRGBEncoding;\n    this.minFilter = LinearFilter;\n    this.magFilter = LinearFilter; // Create an observer on the DOM, and run html2canvas update in the next loop\n\n    const observer = new MutationObserver(() => {\n      if (!this.scheduleUpdate) {\n        // ideally should use xr.requestAnimationFrame, here setTimeout to avoid passing the renderer\n        this.scheduleUpdate = setTimeout(() => this.update(), 16);\n      }\n    });\n    const config = {\n      attributes: true,\n      childList: true,\n      subtree: true,\n      characterData: true\n    };\n    observer.observe(dom, config);\n    this.observer = observer;\n  }\n\n  dispatchDOMEvent(event) {\n    if (event.data) {\n      htmlevent(this.dom, event.type, event.data.x, event.data.y);\n    }\n  }\n\n  update() {\n    this.image = html2canvas(this.dom);\n    this.needsUpdate = true;\n    this.scheduleUpdate = null;\n  }\n\n  dispose() {\n    if (this.observer) {\n      this.observer.disconnect();\n    }\n\n    this.scheduleUpdate = clearTimeout(this.scheduleUpdate);\n    super.dispose();\n  }\n\n} //\n\n\nconst canvases = new WeakMap();\n\nfunction html2canvas(element) {\n  const range = document.createRange();\n  const color = new Color();\n\n  function Clipper(context) {\n    const clips = [];\n    let isClipping = false;\n\n    function doClip() {\n      if (isClipping) {\n        isClipping = false;\n        context.restore();\n      }\n\n      if (clips.length === 0) return;\n      let minX = -Infinity,\n          minY = -Infinity;\n      let maxX = Infinity,\n          maxY = Infinity;\n\n      for (let i = 0; i < clips.length; i++) {\n        const clip = clips[i];\n        minX = Math.max(minX, clip.x);\n        minY = Math.max(minY, clip.y);\n        maxX = Math.min(maxX, clip.x + clip.width);\n        maxY = Math.min(maxY, clip.y + clip.height);\n      }\n\n      context.save();\n      context.beginPath();\n      context.rect(minX, minY, maxX - minX, maxY - minY);\n      context.clip();\n      isClipping = true;\n    }\n\n    return {\n      add: function (clip) {\n        clips.push(clip);\n        doClip();\n      },\n      remove: function () {\n        clips.pop();\n        doClip();\n      }\n    };\n  }\n\n  function drawText(style, x, y, string) {\n    if (string !== '') {\n      if (style.textTransform === 'uppercase') {\n        string = string.toUpperCase();\n      }\n\n      context.font = style.fontWeight + ' ' + style.fontSize + ' ' + style.fontFamily;\n      context.textBaseline = 'top';\n      context.fillStyle = style.color;\n      context.fillText(string, x, y + parseFloat(style.fontSize) * 0.1);\n    }\n  }\n\n  function buildRectPath(x, y, w, h, r) {\n    if (w < 2 * r) r = w / 2;\n    if (h < 2 * r) r = h / 2;\n    context.beginPath();\n    context.moveTo(x + r, y);\n    context.arcTo(x + w, y, x + w, y + h, r);\n    context.arcTo(x + w, y + h, x, y + h, r);\n    context.arcTo(x, y + h, x, y, r);\n    context.arcTo(x, y, x + w, y, r);\n    context.closePath();\n  }\n\n  function drawBorder(style, which, x, y, width, height) {\n    const borderWidth = style[which + 'Width'];\n    const borderStyle = style[which + 'Style'];\n    const borderColor = style[which + 'Color'];\n\n    if (borderWidth !== '0px' && borderStyle !== 'none' && borderColor !== 'transparent' && borderColor !== 'rgba(0, 0, 0, 0)') {\n      context.strokeStyle = borderColor;\n      context.lineWidth = parseFloat(borderWidth);\n      context.beginPath();\n      context.moveTo(x, y);\n      context.lineTo(x + width, y + height);\n      context.stroke();\n    }\n  }\n\n  function drawElement(element, style) {\n    let x = 0,\n        y = 0,\n        width = 0,\n        height = 0;\n\n    if (element.nodeType === Node.TEXT_NODE) {\n      // text\n      range.selectNode(element);\n      const rect = range.getBoundingClientRect();\n      x = rect.left - offset.left - 0.5;\n      y = rect.top - offset.top - 0.5;\n      width = rect.width;\n      height = rect.height;\n      drawText(style, x, y, element.nodeValue.trim());\n    } else if (element.nodeType === Node.COMMENT_NODE) {\n      return;\n    } else if (element instanceof HTMLCanvasElement) {\n      // Canvas element\n      if (element.style.display === 'none') return;\n      context.save();\n      const dpr = window.devicePixelRatio;\n      context.scale(1 / dpr, 1 / dpr);\n      context.drawImage(element, 0, 0);\n      context.restore();\n    } else {\n      if (element.style.display === 'none') return;\n      const rect = element.getBoundingClientRect();\n      x = rect.left - offset.left - 0.5;\n      y = rect.top - offset.top - 0.5;\n      width = rect.width;\n      height = rect.height;\n      style = window.getComputedStyle(element); // Get the border of the element used for fill and border\n\n      buildRectPath(x, y, width, height, parseFloat(style.borderRadius));\n      const backgroundColor = style.backgroundColor;\n\n      if (backgroundColor !== 'transparent' && backgroundColor !== 'rgba(0, 0, 0, 0)') {\n        context.fillStyle = backgroundColor;\n        context.fill();\n      } // If all the borders match then stroke the round rectangle\n\n\n      const borders = ['borderTop', 'borderLeft', 'borderBottom', 'borderRight'];\n      let match = true;\n      let prevBorder = null;\n\n      for (const border of borders) {\n        if (prevBorder !== null) {\n          match = style[border + 'Width'] === style[prevBorder + 'Width'] && style[border + 'Color'] === style[prevBorder + 'Color'] && style[border + 'Style'] === style[prevBorder + 'Style'];\n        }\n\n        if (match === false) break;\n        prevBorder = border;\n      }\n\n      if (match === true) {\n        // They all match so stroke the rectangle from before allows for border-radius\n        const width = parseFloat(style.borderTopWidth);\n\n        if (style.borderTopWidth !== '0px' && style.borderTopStyle !== 'none' && style.borderTopColor !== 'transparent' && style.borderTopColor !== 'rgba(0, 0, 0, 0)') {\n          context.strokeStyle = style.borderTopColor;\n          context.lineWidth = width;\n          context.stroke();\n        }\n      } else {\n        // Otherwise draw individual borders\n        drawBorder(style, 'borderTop', x, y, width, 0);\n        drawBorder(style, 'borderLeft', x, y, 0, height);\n        drawBorder(style, 'borderBottom', x, y + height, width, 0);\n        drawBorder(style, 'borderRight', x + width, y, 0, height);\n      }\n\n      if (element instanceof HTMLInputElement) {\n        let accentColor = style.accentColor;\n        if (accentColor === undefined || accentColor === 'auto') accentColor = style.color;\n        color.set(accentColor);\n        const luminance = Math.sqrt(0.299 * color.r ** 2 + 0.587 * color.g ** 2 + 0.114 * color.b ** 2);\n        const accentTextColor = luminance < 0.5 ? 'white' : '#111111';\n\n        if (element.type === 'radio') {\n          buildRectPath(x, y, width, height, height);\n          context.fillStyle = 'white';\n          context.strokeStyle = accentColor;\n          context.lineWidth = 1;\n          context.fill();\n          context.stroke();\n\n          if (element.checked) {\n            buildRectPath(x + 2, y + 2, width - 4, height - 4, height);\n            context.fillStyle = accentColor;\n            context.strokeStyle = accentTextColor;\n            context.lineWidth = 2;\n            context.fill();\n            context.stroke();\n          }\n        }\n\n        if (element.type === 'checkbox') {\n          buildRectPath(x, y, width, height, 2);\n          context.fillStyle = element.checked ? accentColor : 'white';\n          context.strokeStyle = element.checked ? accentTextColor : accentColor;\n          context.lineWidth = 1;\n          context.stroke();\n          context.fill();\n\n          if (element.checked) {\n            const currentTextAlign = context.textAlign;\n            context.textAlign = 'center';\n            const properties = {\n              color: accentTextColor,\n              fontFamily: style.fontFamily,\n              fontSize: height + 'px',\n              fontWeight: 'bold'\n            };\n            drawText(properties, x + width / 2, y, '✔');\n            context.textAlign = currentTextAlign;\n          }\n        }\n\n        if (element.type === 'range') {\n          const [min, max, value] = ['min', 'max', 'value'].map(property => parseFloat(element[property]));\n          const position = (value - min) / (max - min) * (width - height);\n          buildRectPath(x, y + height / 4, width, height / 2, height / 4);\n          context.fillStyle = accentTextColor;\n          context.strokeStyle = accentColor;\n          context.lineWidth = 1;\n          context.fill();\n          context.stroke();\n          buildRectPath(x, y + height / 4, position + height / 2, height / 2, height / 4);\n          context.fillStyle = accentColor;\n          context.fill();\n          buildRectPath(x + position, y, height, height, height / 2);\n          context.fillStyle = accentColor;\n          context.fill();\n        }\n\n        if (element.type === 'color' || element.type === 'text' || element.type === 'number') {\n          clipper.add({\n            x: x,\n            y: y,\n            width: width,\n            height: height\n          });\n          drawText(style, x + parseInt(style.paddingLeft), y + parseInt(style.paddingTop), element.value);\n          clipper.remove();\n        }\n      }\n    }\n    /*\n    // debug\n    context.strokeStyle = '#' + Math.random().toString( 16 ).slice( - 3 );\n    context.strokeRect( x - 0.5, y - 0.5, width + 1, height + 1 );\n    */\n\n\n    const isClipping = style.overflow === 'auto' || style.overflow === 'hidden';\n    if (isClipping) clipper.add({\n      x: x,\n      y: y,\n      width: width,\n      height: height\n    });\n\n    for (let i = 0; i < element.childNodes.length; i++) {\n      drawElement(element.childNodes[i], style);\n    }\n\n    if (isClipping) clipper.remove();\n  }\n\n  const offset = element.getBoundingClientRect();\n  let canvas = canvases.get(element);\n\n  if (canvas === undefined) {\n    canvas = document.createElement('canvas');\n    canvas.width = offset.width;\n    canvas.height = offset.height;\n    canvases.set(element, canvas);\n  }\n\n  const context = canvas.getContext('2d'\n  /*, { alpha: false }*/\n  );\n  const clipper = new Clipper(context); // console.time( 'drawElement' );\n\n  drawElement(element); // console.timeEnd( 'drawElement' );\n\n  return canvas;\n}\n\nfunction htmlevent(element, event, x, y) {\n  const mouseEventInit = {\n    clientX: x * element.offsetWidth + element.offsetLeft,\n    clientY: y * element.offsetHeight + element.offsetTop,\n    view: element.ownerDocument.defaultView\n  };\n  window.dispatchEvent(new MouseEvent(event, mouseEventInit));\n  const rect = element.getBoundingClientRect();\n  x = x * rect.width + rect.left;\n  y = y * rect.height + rect.top;\n\n  function traverse(element) {\n    if (element.nodeType !== Node.TEXT_NODE && element.nodeType !== Node.COMMENT_NODE) {\n      const rect = element.getBoundingClientRect();\n\n      if (x > rect.left && x < rect.right && y > rect.top && y < rect.bottom) {\n        element.dispatchEvent(new MouseEvent(event, mouseEventInit));\n\n        if (element instanceof HTMLInputElement && element.type === 'range' && (event === 'mousedown' || event === 'click')) {\n          const [min, max] = ['min', 'max'].map(property => parseFloat(element[property]));\n          const width = rect.width;\n          const offsetX = x - rect.x;\n          const proportion = offsetX / width;\n          element.value = min + (max - min) * proportion;\n          element.dispatchEvent(new InputEvent('input', {\n            bubbles: true\n          }));\n        }\n      }\n\n      for (let i = 0; i < element.childNodes.length; i++) {\n        traverse(element.childNodes[i]);\n      }\n    }\n  }\n\n  traverse(element);\n}\n\nexport { HTMLMesh };","map":{"version":3,"names":["Mesh","PlaneGeometry","MeshBasicMaterial","CanvasTexture","sRGBEncoding","LinearFilter","Color","HTMLMesh","constructor","dom","texture","HTMLTexture","geometry","image","width","height","material","map","toneMapped","transparent","onEvent","event","dispatchDOMEvent","addEventListener","dispose","canvases","delete","removeEventListener","html2canvas","anisotropy","encoding","minFilter","magFilter","observer","MutationObserver","scheduleUpdate","setTimeout","update","config","attributes","childList","subtree","characterData","observe","data","htmlevent","type","x","y","needsUpdate","disconnect","clearTimeout","WeakMap","element","range","document","createRange","color","Clipper","context","clips","isClipping","doClip","restore","length","minX","Infinity","minY","maxX","maxY","i","clip","Math","max","min","save","beginPath","rect","add","push","remove","pop","drawText","style","string","textTransform","toUpperCase","font","fontWeight","fontSize","fontFamily","textBaseline","fillStyle","fillText","parseFloat","buildRectPath","w","h","r","moveTo","arcTo","closePath","drawBorder","which","borderWidth","borderStyle","borderColor","strokeStyle","lineWidth","lineTo","stroke","drawElement","nodeType","Node","TEXT_NODE","selectNode","getBoundingClientRect","left","offset","top","nodeValue","trim","COMMENT_NODE","HTMLCanvasElement","display","dpr","window","devicePixelRatio","scale","drawImage","getComputedStyle","borderRadius","backgroundColor","fill","borders","match","prevBorder","border","borderTopWidth","borderTopStyle","borderTopColor","HTMLInputElement","accentColor","undefined","set","luminance","sqrt","g","b","accentTextColor","checked","currentTextAlign","textAlign","properties","value","property","position","clipper","parseInt","paddingLeft","paddingTop","overflow","childNodes","canvas","get","createElement","getContext","mouseEventInit","clientX","offsetWidth","offsetLeft","clientY","offsetHeight","offsetTop","view","ownerDocument","defaultView","dispatchEvent","MouseEvent","traverse","right","bottom","offsetX","proportion","InputEvent","bubbles"],"sources":["/home/rodrigorvsn/workspace/study/threejs-journey/07-react-three-fiber/08-mouse-events-with-r3f/node_modules/three-stdlib/interactive/HTMLMesh.js"],"sourcesContent":["import { Mesh, PlaneGeometry, MeshBasicMaterial, CanvasTexture, sRGBEncoding, LinearFilter, Color } from 'three';\n\nclass HTMLMesh extends Mesh {\n  constructor(dom) {\n    const texture = new HTMLTexture(dom);\n    const geometry = new PlaneGeometry(texture.image.width * 0.001, texture.image.height * 0.001);\n    const material = new MeshBasicMaterial({\n      map: texture,\n      toneMapped: false,\n      transparent: true\n    });\n    super(geometry, material);\n\n    function onEvent(event) {\n      material.map.dispatchDOMEvent(event);\n    }\n\n    this.addEventListener('mousedown', onEvent);\n    this.addEventListener('mousemove', onEvent);\n    this.addEventListener('mouseup', onEvent);\n    this.addEventListener('click', onEvent);\n\n    this.dispose = function () {\n      geometry.dispose();\n      material.dispose();\n      material.map.dispose();\n      canvases.delete(dom);\n      this.removeEventListener('mousedown', onEvent);\n      this.removeEventListener('mousemove', onEvent);\n      this.removeEventListener('mouseup', onEvent);\n      this.removeEventListener('click', onEvent);\n    };\n  }\n\n}\n\nclass HTMLTexture extends CanvasTexture {\n  constructor(dom) {\n    super(html2canvas(dom));\n    this.dom = dom;\n    this.anisotropy = 16;\n    this.encoding = sRGBEncoding;\n    this.minFilter = LinearFilter;\n    this.magFilter = LinearFilter; // Create an observer on the DOM, and run html2canvas update in the next loop\n\n    const observer = new MutationObserver(() => {\n      if (!this.scheduleUpdate) {\n        // ideally should use xr.requestAnimationFrame, here setTimeout to avoid passing the renderer\n        this.scheduleUpdate = setTimeout(() => this.update(), 16);\n      }\n    });\n    const config = {\n      attributes: true,\n      childList: true,\n      subtree: true,\n      characterData: true\n    };\n    observer.observe(dom, config);\n    this.observer = observer;\n  }\n\n  dispatchDOMEvent(event) {\n    if (event.data) {\n      htmlevent(this.dom, event.type, event.data.x, event.data.y);\n    }\n  }\n\n  update() {\n    this.image = html2canvas(this.dom);\n    this.needsUpdate = true;\n    this.scheduleUpdate = null;\n  }\n\n  dispose() {\n    if (this.observer) {\n      this.observer.disconnect();\n    }\n\n    this.scheduleUpdate = clearTimeout(this.scheduleUpdate);\n    super.dispose();\n  }\n\n} //\n\n\nconst canvases = new WeakMap();\n\nfunction html2canvas(element) {\n  const range = document.createRange();\n  const color = new Color();\n\n  function Clipper(context) {\n    const clips = [];\n    let isClipping = false;\n\n    function doClip() {\n      if (isClipping) {\n        isClipping = false;\n        context.restore();\n      }\n\n      if (clips.length === 0) return;\n      let minX = -Infinity,\n          minY = -Infinity;\n      let maxX = Infinity,\n          maxY = Infinity;\n\n      for (let i = 0; i < clips.length; i++) {\n        const clip = clips[i];\n        minX = Math.max(minX, clip.x);\n        minY = Math.max(minY, clip.y);\n        maxX = Math.min(maxX, clip.x + clip.width);\n        maxY = Math.min(maxY, clip.y + clip.height);\n      }\n\n      context.save();\n      context.beginPath();\n      context.rect(minX, minY, maxX - minX, maxY - minY);\n      context.clip();\n      isClipping = true;\n    }\n\n    return {\n      add: function (clip) {\n        clips.push(clip);\n        doClip();\n      },\n      remove: function () {\n        clips.pop();\n        doClip();\n      }\n    };\n  }\n\n  function drawText(style, x, y, string) {\n    if (string !== '') {\n      if (style.textTransform === 'uppercase') {\n        string = string.toUpperCase();\n      }\n\n      context.font = style.fontWeight + ' ' + style.fontSize + ' ' + style.fontFamily;\n      context.textBaseline = 'top';\n      context.fillStyle = style.color;\n      context.fillText(string, x, y + parseFloat(style.fontSize) * 0.1);\n    }\n  }\n\n  function buildRectPath(x, y, w, h, r) {\n    if (w < 2 * r) r = w / 2;\n    if (h < 2 * r) r = h / 2;\n    context.beginPath();\n    context.moveTo(x + r, y);\n    context.arcTo(x + w, y, x + w, y + h, r);\n    context.arcTo(x + w, y + h, x, y + h, r);\n    context.arcTo(x, y + h, x, y, r);\n    context.arcTo(x, y, x + w, y, r);\n    context.closePath();\n  }\n\n  function drawBorder(style, which, x, y, width, height) {\n    const borderWidth = style[which + 'Width'];\n    const borderStyle = style[which + 'Style'];\n    const borderColor = style[which + 'Color'];\n\n    if (borderWidth !== '0px' && borderStyle !== 'none' && borderColor !== 'transparent' && borderColor !== 'rgba(0, 0, 0, 0)') {\n      context.strokeStyle = borderColor;\n      context.lineWidth = parseFloat(borderWidth);\n      context.beginPath();\n      context.moveTo(x, y);\n      context.lineTo(x + width, y + height);\n      context.stroke();\n    }\n  }\n\n  function drawElement(element, style) {\n    let x = 0,\n        y = 0,\n        width = 0,\n        height = 0;\n\n    if (element.nodeType === Node.TEXT_NODE) {\n      // text\n      range.selectNode(element);\n      const rect = range.getBoundingClientRect();\n      x = rect.left - offset.left - 0.5;\n      y = rect.top - offset.top - 0.5;\n      width = rect.width;\n      height = rect.height;\n      drawText(style, x, y, element.nodeValue.trim());\n    } else if (element.nodeType === Node.COMMENT_NODE) {\n      return;\n    } else if (element instanceof HTMLCanvasElement) {\n      // Canvas element\n      if (element.style.display === 'none') return;\n      context.save();\n      const dpr = window.devicePixelRatio;\n      context.scale(1 / dpr, 1 / dpr);\n      context.drawImage(element, 0, 0);\n      context.restore();\n    } else {\n      if (element.style.display === 'none') return;\n      const rect = element.getBoundingClientRect();\n      x = rect.left - offset.left - 0.5;\n      y = rect.top - offset.top - 0.5;\n      width = rect.width;\n      height = rect.height;\n      style = window.getComputedStyle(element); // Get the border of the element used for fill and border\n\n      buildRectPath(x, y, width, height, parseFloat(style.borderRadius));\n      const backgroundColor = style.backgroundColor;\n\n      if (backgroundColor !== 'transparent' && backgroundColor !== 'rgba(0, 0, 0, 0)') {\n        context.fillStyle = backgroundColor;\n        context.fill();\n      } // If all the borders match then stroke the round rectangle\n\n\n      const borders = ['borderTop', 'borderLeft', 'borderBottom', 'borderRight'];\n      let match = true;\n      let prevBorder = null;\n\n      for (const border of borders) {\n        if (prevBorder !== null) {\n          match = style[border + 'Width'] === style[prevBorder + 'Width'] && style[border + 'Color'] === style[prevBorder + 'Color'] && style[border + 'Style'] === style[prevBorder + 'Style'];\n        }\n\n        if (match === false) break;\n        prevBorder = border;\n      }\n\n      if (match === true) {\n        // They all match so stroke the rectangle from before allows for border-radius\n        const width = parseFloat(style.borderTopWidth);\n\n        if (style.borderTopWidth !== '0px' && style.borderTopStyle !== 'none' && style.borderTopColor !== 'transparent' && style.borderTopColor !== 'rgba(0, 0, 0, 0)') {\n          context.strokeStyle = style.borderTopColor;\n          context.lineWidth = width;\n          context.stroke();\n        }\n      } else {\n        // Otherwise draw individual borders\n        drawBorder(style, 'borderTop', x, y, width, 0);\n        drawBorder(style, 'borderLeft', x, y, 0, height);\n        drawBorder(style, 'borderBottom', x, y + height, width, 0);\n        drawBorder(style, 'borderRight', x + width, y, 0, height);\n      }\n\n      if (element instanceof HTMLInputElement) {\n        let accentColor = style.accentColor;\n        if (accentColor === undefined || accentColor === 'auto') accentColor = style.color;\n        color.set(accentColor);\n        const luminance = Math.sqrt(0.299 * color.r ** 2 + 0.587 * color.g ** 2 + 0.114 * color.b ** 2);\n        const accentTextColor = luminance < 0.5 ? 'white' : '#111111';\n\n        if (element.type === 'radio') {\n          buildRectPath(x, y, width, height, height);\n          context.fillStyle = 'white';\n          context.strokeStyle = accentColor;\n          context.lineWidth = 1;\n          context.fill();\n          context.stroke();\n\n          if (element.checked) {\n            buildRectPath(x + 2, y + 2, width - 4, height - 4, height);\n            context.fillStyle = accentColor;\n            context.strokeStyle = accentTextColor;\n            context.lineWidth = 2;\n            context.fill();\n            context.stroke();\n          }\n        }\n\n        if (element.type === 'checkbox') {\n          buildRectPath(x, y, width, height, 2);\n          context.fillStyle = element.checked ? accentColor : 'white';\n          context.strokeStyle = element.checked ? accentTextColor : accentColor;\n          context.lineWidth = 1;\n          context.stroke();\n          context.fill();\n\n          if (element.checked) {\n            const currentTextAlign = context.textAlign;\n            context.textAlign = 'center';\n            const properties = {\n              color: accentTextColor,\n              fontFamily: style.fontFamily,\n              fontSize: height + 'px',\n              fontWeight: 'bold'\n            };\n            drawText(properties, x + width / 2, y, '✔');\n            context.textAlign = currentTextAlign;\n          }\n        }\n\n        if (element.type === 'range') {\n          const [min, max, value] = ['min', 'max', 'value'].map(property => parseFloat(element[property]));\n          const position = (value - min) / (max - min) * (width - height);\n          buildRectPath(x, y + height / 4, width, height / 2, height / 4);\n          context.fillStyle = accentTextColor;\n          context.strokeStyle = accentColor;\n          context.lineWidth = 1;\n          context.fill();\n          context.stroke();\n          buildRectPath(x, y + height / 4, position + height / 2, height / 2, height / 4);\n          context.fillStyle = accentColor;\n          context.fill();\n          buildRectPath(x + position, y, height, height, height / 2);\n          context.fillStyle = accentColor;\n          context.fill();\n        }\n\n        if (element.type === 'color' || element.type === 'text' || element.type === 'number') {\n          clipper.add({\n            x: x,\n            y: y,\n            width: width,\n            height: height\n          });\n          drawText(style, x + parseInt(style.paddingLeft), y + parseInt(style.paddingTop), element.value);\n          clipper.remove();\n        }\n      }\n    }\n    /*\n    // debug\n    context.strokeStyle = '#' + Math.random().toString( 16 ).slice( - 3 );\n    context.strokeRect( x - 0.5, y - 0.5, width + 1, height + 1 );\n    */\n\n\n    const isClipping = style.overflow === 'auto' || style.overflow === 'hidden';\n    if (isClipping) clipper.add({\n      x: x,\n      y: y,\n      width: width,\n      height: height\n    });\n\n    for (let i = 0; i < element.childNodes.length; i++) {\n      drawElement(element.childNodes[i], style);\n    }\n\n    if (isClipping) clipper.remove();\n  }\n\n  const offset = element.getBoundingClientRect();\n  let canvas = canvases.get(element);\n\n  if (canvas === undefined) {\n    canvas = document.createElement('canvas');\n    canvas.width = offset.width;\n    canvas.height = offset.height;\n    canvases.set(element, canvas);\n  }\n\n  const context = canvas.getContext('2d'\n  /*, { alpha: false }*/\n  );\n  const clipper = new Clipper(context); // console.time( 'drawElement' );\n\n  drawElement(element); // console.timeEnd( 'drawElement' );\n\n  return canvas;\n}\n\nfunction htmlevent(element, event, x, y) {\n  const mouseEventInit = {\n    clientX: x * element.offsetWidth + element.offsetLeft,\n    clientY: y * element.offsetHeight + element.offsetTop,\n    view: element.ownerDocument.defaultView\n  };\n  window.dispatchEvent(new MouseEvent(event, mouseEventInit));\n  const rect = element.getBoundingClientRect();\n  x = x * rect.width + rect.left;\n  y = y * rect.height + rect.top;\n\n  function traverse(element) {\n    if (element.nodeType !== Node.TEXT_NODE && element.nodeType !== Node.COMMENT_NODE) {\n      const rect = element.getBoundingClientRect();\n\n      if (x > rect.left && x < rect.right && y > rect.top && y < rect.bottom) {\n        element.dispatchEvent(new MouseEvent(event, mouseEventInit));\n\n        if (element instanceof HTMLInputElement && element.type === 'range' && (event === 'mousedown' || event === 'click')) {\n          const [min, max] = ['min', 'max'].map(property => parseFloat(element[property]));\n          const width = rect.width;\n          const offsetX = x - rect.x;\n          const proportion = offsetX / width;\n          element.value = min + (max - min) * proportion;\n          element.dispatchEvent(new InputEvent('input', {\n            bubbles: true\n          }));\n        }\n      }\n\n      for (let i = 0; i < element.childNodes.length; i++) {\n        traverse(element.childNodes[i]);\n      }\n    }\n  }\n\n  traverse(element);\n}\n\nexport { HTMLMesh };\n"],"mappings":"AAAA,SAASA,IAAT,EAAeC,aAAf,EAA8BC,iBAA9B,EAAiDC,aAAjD,EAAgEC,YAAhE,EAA8EC,YAA9E,EAA4FC,KAA5F,QAAyG,OAAzG;;AAEA,MAAMC,QAAN,SAAuBP,IAAvB,CAA4B;EAC1BQ,WAAW,CAACC,GAAD,EAAM;IACf,MAAMC,OAAO,GAAG,IAAIC,WAAJ,CAAgBF,GAAhB,CAAhB;IACA,MAAMG,QAAQ,GAAG,IAAIX,aAAJ,CAAkBS,OAAO,CAACG,KAAR,CAAcC,KAAd,GAAsB,KAAxC,EAA+CJ,OAAO,CAACG,KAAR,CAAcE,MAAd,GAAuB,KAAtE,CAAjB;IACA,MAAMC,QAAQ,GAAG,IAAId,iBAAJ,CAAsB;MACrCe,GAAG,EAAEP,OADgC;MAErCQ,UAAU,EAAE,KAFyB;MAGrCC,WAAW,EAAE;IAHwB,CAAtB,CAAjB;IAKA,MAAMP,QAAN,EAAgBI,QAAhB;;IAEA,SAASI,OAAT,CAAiBC,KAAjB,EAAwB;MACtBL,QAAQ,CAACC,GAAT,CAAaK,gBAAb,CAA8BD,KAA9B;IACD;;IAED,KAAKE,gBAAL,CAAsB,WAAtB,EAAmCH,OAAnC;IACA,KAAKG,gBAAL,CAAsB,WAAtB,EAAmCH,OAAnC;IACA,KAAKG,gBAAL,CAAsB,SAAtB,EAAiCH,OAAjC;IACA,KAAKG,gBAAL,CAAsB,OAAtB,EAA+BH,OAA/B;;IAEA,KAAKI,OAAL,GAAe,YAAY;MACzBZ,QAAQ,CAACY,OAAT;MACAR,QAAQ,CAACQ,OAAT;MACAR,QAAQ,CAACC,GAAT,CAAaO,OAAb;MACAC,QAAQ,CAACC,MAAT,CAAgBjB,GAAhB;MACA,KAAKkB,mBAAL,CAAyB,WAAzB,EAAsCP,OAAtC;MACA,KAAKO,mBAAL,CAAyB,WAAzB,EAAsCP,OAAtC;MACA,KAAKO,mBAAL,CAAyB,SAAzB,EAAoCP,OAApC;MACA,KAAKO,mBAAL,CAAyB,OAAzB,EAAkCP,OAAlC;IACD,CATD;EAUD;;AA9ByB;;AAkC5B,MAAMT,WAAN,SAA0BR,aAA1B,CAAwC;EACtCK,WAAW,CAACC,GAAD,EAAM;IACf,MAAMmB,WAAW,CAACnB,GAAD,CAAjB;IACA,KAAKA,GAAL,GAAWA,GAAX;IACA,KAAKoB,UAAL,GAAkB,EAAlB;IACA,KAAKC,QAAL,GAAgB1B,YAAhB;IACA,KAAK2B,SAAL,GAAiB1B,YAAjB;IACA,KAAK2B,SAAL,GAAiB3B,YAAjB,CANe,CAMgB;;IAE/B,MAAM4B,QAAQ,GAAG,IAAIC,gBAAJ,CAAqB,MAAM;MAC1C,IAAI,CAAC,KAAKC,cAAV,EAA0B;QACxB;QACA,KAAKA,cAAL,GAAsBC,UAAU,CAAC,MAAM,KAAKC,MAAL,EAAP,EAAsB,EAAtB,CAAhC;MACD;IACF,CALgB,CAAjB;IAMA,MAAMC,MAAM,GAAG;MACbC,UAAU,EAAE,IADC;MAEbC,SAAS,EAAE,IAFE;MAGbC,OAAO,EAAE,IAHI;MAIbC,aAAa,EAAE;IAJF,CAAf;IAMAT,QAAQ,CAACU,OAAT,CAAiBlC,GAAjB,EAAsB6B,MAAtB;IACA,KAAKL,QAAL,GAAgBA,QAAhB;EACD;;EAEDX,gBAAgB,CAACD,KAAD,EAAQ;IACtB,IAAIA,KAAK,CAACuB,IAAV,EAAgB;MACdC,SAAS,CAAC,KAAKpC,GAAN,EAAWY,KAAK,CAACyB,IAAjB,EAAuBzB,KAAK,CAACuB,IAAN,CAAWG,CAAlC,EAAqC1B,KAAK,CAACuB,IAAN,CAAWI,CAAhD,CAAT;IACD;EACF;;EAEDX,MAAM,GAAG;IACP,KAAKxB,KAAL,GAAae,WAAW,CAAC,KAAKnB,GAAN,CAAxB;IACA,KAAKwC,WAAL,GAAmB,IAAnB;IACA,KAAKd,cAAL,GAAsB,IAAtB;EACD;;EAEDX,OAAO,GAAG;IACR,IAAI,KAAKS,QAAT,EAAmB;MACjB,KAAKA,QAAL,CAAciB,UAAd;IACD;;IAED,KAAKf,cAAL,GAAsBgB,YAAY,CAAC,KAAKhB,cAAN,CAAlC;IACA,MAAMX,OAAN;EACD;;AA5CqC,C,CA8CtC;;;AAGF,MAAMC,QAAQ,GAAG,IAAI2B,OAAJ,EAAjB;;AAEA,SAASxB,WAAT,CAAqByB,OAArB,EAA8B;EAC5B,MAAMC,KAAK,GAAGC,QAAQ,CAACC,WAAT,EAAd;EACA,MAAMC,KAAK,GAAG,IAAInD,KAAJ,EAAd;;EAEA,SAASoD,OAAT,CAAiBC,OAAjB,EAA0B;IACxB,MAAMC,KAAK,GAAG,EAAd;IACA,IAAIC,UAAU,GAAG,KAAjB;;IAEA,SAASC,MAAT,GAAkB;MAChB,IAAID,UAAJ,EAAgB;QACdA,UAAU,GAAG,KAAb;QACAF,OAAO,CAACI,OAAR;MACD;;MAED,IAAIH,KAAK,CAACI,MAAN,KAAiB,CAArB,EAAwB;MACxB,IAAIC,IAAI,GAAG,CAACC,QAAZ;MAAA,IACIC,IAAI,GAAG,CAACD,QADZ;MAEA,IAAIE,IAAI,GAAGF,QAAX;MAAA,IACIG,IAAI,GAAGH,QADX;;MAGA,KAAK,IAAII,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGV,KAAK,CAACI,MAA1B,EAAkCM,CAAC,EAAnC,EAAuC;QACrC,MAAMC,IAAI,GAAGX,KAAK,CAACU,CAAD,CAAlB;QACAL,IAAI,GAAGO,IAAI,CAACC,GAAL,CAASR,IAAT,EAAeM,IAAI,CAACxB,CAApB,CAAP;QACAoB,IAAI,GAAGK,IAAI,CAACC,GAAL,CAASN,IAAT,EAAeI,IAAI,CAACvB,CAApB,CAAP;QACAoB,IAAI,GAAGI,IAAI,CAACE,GAAL,CAASN,IAAT,EAAeG,IAAI,CAACxB,CAAL,GAASwB,IAAI,CAACzD,KAA7B,CAAP;QACAuD,IAAI,GAAGG,IAAI,CAACE,GAAL,CAASL,IAAT,EAAeE,IAAI,CAACvB,CAAL,GAASuB,IAAI,CAACxD,MAA7B,CAAP;MACD;;MAED4C,OAAO,CAACgB,IAAR;MACAhB,OAAO,CAACiB,SAAR;MACAjB,OAAO,CAACkB,IAAR,CAAaZ,IAAb,EAAmBE,IAAnB,EAAyBC,IAAI,GAAGH,IAAhC,EAAsCI,IAAI,GAAGF,IAA7C;MACAR,OAAO,CAACY,IAAR;MACAV,UAAU,GAAG,IAAb;IACD;;IAED,OAAO;MACLiB,GAAG,EAAE,UAAUP,IAAV,EAAgB;QACnBX,KAAK,CAACmB,IAAN,CAAWR,IAAX;QACAT,MAAM;MACP,CAJI;MAKLkB,MAAM,EAAE,YAAY;QAClBpB,KAAK,CAACqB,GAAN;QACAnB,MAAM;MACP;IARI,CAAP;EAUD;;EAED,SAASoB,QAAT,CAAkBC,KAAlB,EAAyBpC,CAAzB,EAA4BC,CAA5B,EAA+BoC,MAA/B,EAAuC;IACrC,IAAIA,MAAM,KAAK,EAAf,EAAmB;MACjB,IAAID,KAAK,CAACE,aAAN,KAAwB,WAA5B,EAAyC;QACvCD,MAAM,GAAGA,MAAM,CAACE,WAAP,EAAT;MACD;;MAED3B,OAAO,CAAC4B,IAAR,GAAeJ,KAAK,CAACK,UAAN,GAAmB,GAAnB,GAAyBL,KAAK,CAACM,QAA/B,GAA0C,GAA1C,GAAgDN,KAAK,CAACO,UAArE;MACA/B,OAAO,CAACgC,YAAR,GAAuB,KAAvB;MACAhC,OAAO,CAACiC,SAAR,GAAoBT,KAAK,CAAC1B,KAA1B;MACAE,OAAO,CAACkC,QAAR,CAAiBT,MAAjB,EAAyBrC,CAAzB,EAA4BC,CAAC,GAAG8C,UAAU,CAACX,KAAK,CAACM,QAAP,CAAV,GAA6B,GAA7D;IACD;EACF;;EAED,SAASM,aAAT,CAAuBhD,CAAvB,EAA0BC,CAA1B,EAA6BgD,CAA7B,EAAgCC,CAAhC,EAAmCC,CAAnC,EAAsC;IACpC,IAAIF,CAAC,GAAG,IAAIE,CAAZ,EAAeA,CAAC,GAAGF,CAAC,GAAG,CAAR;IACf,IAAIC,CAAC,GAAG,IAAIC,CAAZ,EAAeA,CAAC,GAAGD,CAAC,GAAG,CAAR;IACftC,OAAO,CAACiB,SAAR;IACAjB,OAAO,CAACwC,MAAR,CAAepD,CAAC,GAAGmD,CAAnB,EAAsBlD,CAAtB;IACAW,OAAO,CAACyC,KAAR,CAAcrD,CAAC,GAAGiD,CAAlB,EAAqBhD,CAArB,EAAwBD,CAAC,GAAGiD,CAA5B,EAA+BhD,CAAC,GAAGiD,CAAnC,EAAsCC,CAAtC;IACAvC,OAAO,CAACyC,KAAR,CAAcrD,CAAC,GAAGiD,CAAlB,EAAqBhD,CAAC,GAAGiD,CAAzB,EAA4BlD,CAA5B,EAA+BC,CAAC,GAAGiD,CAAnC,EAAsCC,CAAtC;IACAvC,OAAO,CAACyC,KAAR,CAAcrD,CAAd,EAAiBC,CAAC,GAAGiD,CAArB,EAAwBlD,CAAxB,EAA2BC,CAA3B,EAA8BkD,CAA9B;IACAvC,OAAO,CAACyC,KAAR,CAAcrD,CAAd,EAAiBC,CAAjB,EAAoBD,CAAC,GAAGiD,CAAxB,EAA2BhD,CAA3B,EAA8BkD,CAA9B;IACAvC,OAAO,CAAC0C,SAAR;EACD;;EAED,SAASC,UAAT,CAAoBnB,KAApB,EAA2BoB,KAA3B,EAAkCxD,CAAlC,EAAqCC,CAArC,EAAwClC,KAAxC,EAA+CC,MAA/C,EAAuD;IACrD,MAAMyF,WAAW,GAAGrB,KAAK,CAACoB,KAAK,GAAG,OAAT,CAAzB;IACA,MAAME,WAAW,GAAGtB,KAAK,CAACoB,KAAK,GAAG,OAAT,CAAzB;IACA,MAAMG,WAAW,GAAGvB,KAAK,CAACoB,KAAK,GAAG,OAAT,CAAzB;;IAEA,IAAIC,WAAW,KAAK,KAAhB,IAAyBC,WAAW,KAAK,MAAzC,IAAmDC,WAAW,KAAK,aAAnE,IAAoFA,WAAW,KAAK,kBAAxG,EAA4H;MAC1H/C,OAAO,CAACgD,WAAR,GAAsBD,WAAtB;MACA/C,OAAO,CAACiD,SAAR,GAAoBd,UAAU,CAACU,WAAD,CAA9B;MACA7C,OAAO,CAACiB,SAAR;MACAjB,OAAO,CAACwC,MAAR,CAAepD,CAAf,EAAkBC,CAAlB;MACAW,OAAO,CAACkD,MAAR,CAAe9D,CAAC,GAAGjC,KAAnB,EAA0BkC,CAAC,GAAGjC,MAA9B;MACA4C,OAAO,CAACmD,MAAR;IACD;EACF;;EAED,SAASC,WAAT,CAAqB1D,OAArB,EAA8B8B,KAA9B,EAAqC;IACnC,IAAIpC,CAAC,GAAG,CAAR;IAAA,IACIC,CAAC,GAAG,CADR;IAAA,IAEIlC,KAAK,GAAG,CAFZ;IAAA,IAGIC,MAAM,GAAG,CAHb;;IAKA,IAAIsC,OAAO,CAAC2D,QAAR,KAAqBC,IAAI,CAACC,SAA9B,EAAyC;MACvC;MACA5D,KAAK,CAAC6D,UAAN,CAAiB9D,OAAjB;MACA,MAAMwB,IAAI,GAAGvB,KAAK,CAAC8D,qBAAN,EAAb;MACArE,CAAC,GAAG8B,IAAI,CAACwC,IAAL,GAAYC,MAAM,CAACD,IAAnB,GAA0B,GAA9B;MACArE,CAAC,GAAG6B,IAAI,CAAC0C,GAAL,GAAWD,MAAM,CAACC,GAAlB,GAAwB,GAA5B;MACAzG,KAAK,GAAG+D,IAAI,CAAC/D,KAAb;MACAC,MAAM,GAAG8D,IAAI,CAAC9D,MAAd;MACAmE,QAAQ,CAACC,KAAD,EAAQpC,CAAR,EAAWC,CAAX,EAAcK,OAAO,CAACmE,SAAR,CAAkBC,IAAlB,EAAd,CAAR;IACD,CATD,MASO,IAAIpE,OAAO,CAAC2D,QAAR,KAAqBC,IAAI,CAACS,YAA9B,EAA4C;MACjD;IACD,CAFM,MAEA,IAAIrE,OAAO,YAAYsE,iBAAvB,EAA0C;MAC/C;MACA,IAAItE,OAAO,CAAC8B,KAAR,CAAcyC,OAAd,KAA0B,MAA9B,EAAsC;MACtCjE,OAAO,CAACgB,IAAR;MACA,MAAMkD,GAAG,GAAGC,MAAM,CAACC,gBAAnB;MACApE,OAAO,CAACqE,KAAR,CAAc,IAAIH,GAAlB,EAAuB,IAAIA,GAA3B;MACAlE,OAAO,CAACsE,SAAR,CAAkB5E,OAAlB,EAA2B,CAA3B,EAA8B,CAA9B;MACAM,OAAO,CAACI,OAAR;IACD,CARM,MAQA;MACL,IAAIV,OAAO,CAAC8B,KAAR,CAAcyC,OAAd,KAA0B,MAA9B,EAAsC;MACtC,MAAM/C,IAAI,GAAGxB,OAAO,CAAC+D,qBAAR,EAAb;MACArE,CAAC,GAAG8B,IAAI,CAACwC,IAAL,GAAYC,MAAM,CAACD,IAAnB,GAA0B,GAA9B;MACArE,CAAC,GAAG6B,IAAI,CAAC0C,GAAL,GAAWD,MAAM,CAACC,GAAlB,GAAwB,GAA5B;MACAzG,KAAK,GAAG+D,IAAI,CAAC/D,KAAb;MACAC,MAAM,GAAG8D,IAAI,CAAC9D,MAAd;MACAoE,KAAK,GAAG2C,MAAM,CAACI,gBAAP,CAAwB7E,OAAxB,CAAR,CAPK,CAOqC;;MAE1C0C,aAAa,CAAChD,CAAD,EAAIC,CAAJ,EAAOlC,KAAP,EAAcC,MAAd,EAAsB+E,UAAU,CAACX,KAAK,CAACgD,YAAP,CAAhC,CAAb;MACA,MAAMC,eAAe,GAAGjD,KAAK,CAACiD,eAA9B;;MAEA,IAAIA,eAAe,KAAK,aAApB,IAAqCA,eAAe,KAAK,kBAA7D,EAAiF;QAC/EzE,OAAO,CAACiC,SAAR,GAAoBwC,eAApB;QACAzE,OAAO,CAAC0E,IAAR;MACD,CAfI,CAeH;;;MAGF,MAAMC,OAAO,GAAG,CAAC,WAAD,EAAc,YAAd,EAA4B,cAA5B,EAA4C,aAA5C,CAAhB;MACA,IAAIC,KAAK,GAAG,IAAZ;MACA,IAAIC,UAAU,GAAG,IAAjB;;MAEA,KAAK,MAAMC,MAAX,IAAqBH,OAArB,EAA8B;QAC5B,IAAIE,UAAU,KAAK,IAAnB,EAAyB;UACvBD,KAAK,GAAGpD,KAAK,CAACsD,MAAM,GAAG,OAAV,CAAL,KAA4BtD,KAAK,CAACqD,UAAU,GAAG,OAAd,CAAjC,IAA2DrD,KAAK,CAACsD,MAAM,GAAG,OAAV,CAAL,KAA4BtD,KAAK,CAACqD,UAAU,GAAG,OAAd,CAA5F,IAAsHrD,KAAK,CAACsD,MAAM,GAAG,OAAV,CAAL,KAA4BtD,KAAK,CAACqD,UAAU,GAAG,OAAd,CAA/J;QACD;;QAED,IAAID,KAAK,KAAK,KAAd,EAAqB;QACrBC,UAAU,GAAGC,MAAb;MACD;;MAED,IAAIF,KAAK,KAAK,IAAd,EAAoB;QAClB;QACA,MAAMzH,KAAK,GAAGgF,UAAU,CAACX,KAAK,CAACuD,cAAP,CAAxB;;QAEA,IAAIvD,KAAK,CAACuD,cAAN,KAAyB,KAAzB,IAAkCvD,KAAK,CAACwD,cAAN,KAAyB,MAA3D,IAAqExD,KAAK,CAACyD,cAAN,KAAyB,aAA9F,IAA+GzD,KAAK,CAACyD,cAAN,KAAyB,kBAA5I,EAAgK;UAC9JjF,OAAO,CAACgD,WAAR,GAAsBxB,KAAK,CAACyD,cAA5B;UACAjF,OAAO,CAACiD,SAAR,GAAoB9F,KAApB;UACA6C,OAAO,CAACmD,MAAR;QACD;MACF,CATD,MASO;QACL;QACAR,UAAU,CAACnB,KAAD,EAAQ,WAAR,EAAqBpC,CAArB,EAAwBC,CAAxB,EAA2BlC,KAA3B,EAAkC,CAAlC,CAAV;QACAwF,UAAU,CAACnB,KAAD,EAAQ,YAAR,EAAsBpC,CAAtB,EAAyBC,CAAzB,EAA4B,CAA5B,EAA+BjC,MAA/B,CAAV;QACAuF,UAAU,CAACnB,KAAD,EAAQ,cAAR,EAAwBpC,CAAxB,EAA2BC,CAAC,GAAGjC,MAA/B,EAAuCD,KAAvC,EAA8C,CAA9C,CAAV;QACAwF,UAAU,CAACnB,KAAD,EAAQ,aAAR,EAAuBpC,CAAC,GAAGjC,KAA3B,EAAkCkC,CAAlC,EAAqC,CAArC,EAAwCjC,MAAxC,CAAV;MACD;;MAED,IAAIsC,OAAO,YAAYwF,gBAAvB,EAAyC;QACvC,IAAIC,WAAW,GAAG3D,KAAK,CAAC2D,WAAxB;QACA,IAAIA,WAAW,KAAKC,SAAhB,IAA6BD,WAAW,KAAK,MAAjD,EAAyDA,WAAW,GAAG3D,KAAK,CAAC1B,KAApB;QACzDA,KAAK,CAACuF,GAAN,CAAUF,WAAV;QACA,MAAMG,SAAS,GAAGzE,IAAI,CAAC0E,IAAL,CAAU,QAAQzF,KAAK,CAACyC,CAAN,IAAW,CAAnB,GAAuB,QAAQzC,KAAK,CAAC0F,CAAN,IAAW,CAA1C,GAA8C,QAAQ1F,KAAK,CAAC2F,CAAN,IAAW,CAA3E,CAAlB;QACA,MAAMC,eAAe,GAAGJ,SAAS,GAAG,GAAZ,GAAkB,OAAlB,GAA4B,SAApD;;QAEA,IAAI5F,OAAO,CAACP,IAAR,KAAiB,OAArB,EAA8B;UAC5BiD,aAAa,CAAChD,CAAD,EAAIC,CAAJ,EAAOlC,KAAP,EAAcC,MAAd,EAAsBA,MAAtB,CAAb;UACA4C,OAAO,CAACiC,SAAR,GAAoB,OAApB;UACAjC,OAAO,CAACgD,WAAR,GAAsBmC,WAAtB;UACAnF,OAAO,CAACiD,SAAR,GAAoB,CAApB;UACAjD,OAAO,CAAC0E,IAAR;UACA1E,OAAO,CAACmD,MAAR;;UAEA,IAAIzD,OAAO,CAACiG,OAAZ,EAAqB;YACnBvD,aAAa,CAAChD,CAAC,GAAG,CAAL,EAAQC,CAAC,GAAG,CAAZ,EAAelC,KAAK,GAAG,CAAvB,EAA0BC,MAAM,GAAG,CAAnC,EAAsCA,MAAtC,CAAb;YACA4C,OAAO,CAACiC,SAAR,GAAoBkD,WAApB;YACAnF,OAAO,CAACgD,WAAR,GAAsB0C,eAAtB;YACA1F,OAAO,CAACiD,SAAR,GAAoB,CAApB;YACAjD,OAAO,CAAC0E,IAAR;YACA1E,OAAO,CAACmD,MAAR;UACD;QACF;;QAED,IAAIzD,OAAO,CAACP,IAAR,KAAiB,UAArB,EAAiC;UAC/BiD,aAAa,CAAChD,CAAD,EAAIC,CAAJ,EAAOlC,KAAP,EAAcC,MAAd,EAAsB,CAAtB,CAAb;UACA4C,OAAO,CAACiC,SAAR,GAAoBvC,OAAO,CAACiG,OAAR,GAAkBR,WAAlB,GAAgC,OAApD;UACAnF,OAAO,CAACgD,WAAR,GAAsBtD,OAAO,CAACiG,OAAR,GAAkBD,eAAlB,GAAoCP,WAA1D;UACAnF,OAAO,CAACiD,SAAR,GAAoB,CAApB;UACAjD,OAAO,CAACmD,MAAR;UACAnD,OAAO,CAAC0E,IAAR;;UAEA,IAAIhF,OAAO,CAACiG,OAAZ,EAAqB;YACnB,MAAMC,gBAAgB,GAAG5F,OAAO,CAAC6F,SAAjC;YACA7F,OAAO,CAAC6F,SAAR,GAAoB,QAApB;YACA,MAAMC,UAAU,GAAG;cACjBhG,KAAK,EAAE4F,eADU;cAEjB3D,UAAU,EAAEP,KAAK,CAACO,UAFD;cAGjBD,QAAQ,EAAE1E,MAAM,GAAG,IAHF;cAIjByE,UAAU,EAAE;YAJK,CAAnB;YAMAN,QAAQ,CAACuE,UAAD,EAAa1G,CAAC,GAAGjC,KAAK,GAAG,CAAzB,EAA4BkC,CAA5B,EAA+B,GAA/B,CAAR;YACAW,OAAO,CAAC6F,SAAR,GAAoBD,gBAApB;UACD;QACF;;QAED,IAAIlG,OAAO,CAACP,IAAR,KAAiB,OAArB,EAA8B;UAC5B,MAAM,CAAC4B,GAAD,EAAMD,GAAN,EAAWiF,KAAX,IAAoB,CAAC,KAAD,EAAQ,KAAR,EAAe,OAAf,EAAwBzI,GAAxB,CAA4B0I,QAAQ,IAAI7D,UAAU,CAACzC,OAAO,CAACsG,QAAD,CAAR,CAAlD,CAA1B;UACA,MAAMC,QAAQ,GAAG,CAACF,KAAK,GAAGhF,GAAT,KAAiBD,GAAG,GAAGC,GAAvB,KAA+B5D,KAAK,GAAGC,MAAvC,CAAjB;UACAgF,aAAa,CAAChD,CAAD,EAAIC,CAAC,GAAGjC,MAAM,GAAG,CAAjB,EAAoBD,KAApB,EAA2BC,MAAM,GAAG,CAApC,EAAuCA,MAAM,GAAG,CAAhD,CAAb;UACA4C,OAAO,CAACiC,SAAR,GAAoByD,eAApB;UACA1F,OAAO,CAACgD,WAAR,GAAsBmC,WAAtB;UACAnF,OAAO,CAACiD,SAAR,GAAoB,CAApB;UACAjD,OAAO,CAAC0E,IAAR;UACA1E,OAAO,CAACmD,MAAR;UACAf,aAAa,CAAChD,CAAD,EAAIC,CAAC,GAAGjC,MAAM,GAAG,CAAjB,EAAoB6I,QAAQ,GAAG7I,MAAM,GAAG,CAAxC,EAA2CA,MAAM,GAAG,CAApD,EAAuDA,MAAM,GAAG,CAAhE,CAAb;UACA4C,OAAO,CAACiC,SAAR,GAAoBkD,WAApB;UACAnF,OAAO,CAAC0E,IAAR;UACAtC,aAAa,CAAChD,CAAC,GAAG6G,QAAL,EAAe5G,CAAf,EAAkBjC,MAAlB,EAA0BA,MAA1B,EAAkCA,MAAM,GAAG,CAA3C,CAAb;UACA4C,OAAO,CAACiC,SAAR,GAAoBkD,WAApB;UACAnF,OAAO,CAAC0E,IAAR;QACD;;QAED,IAAIhF,OAAO,CAACP,IAAR,KAAiB,OAAjB,IAA4BO,OAAO,CAACP,IAAR,KAAiB,MAA7C,IAAuDO,OAAO,CAACP,IAAR,KAAiB,QAA5E,EAAsF;UACpF+G,OAAO,CAAC/E,GAAR,CAAY;YACV/B,CAAC,EAAEA,CADO;YAEVC,CAAC,EAAEA,CAFO;YAGVlC,KAAK,EAAEA,KAHG;YAIVC,MAAM,EAAEA;UAJE,CAAZ;UAMAmE,QAAQ,CAACC,KAAD,EAAQpC,CAAC,GAAG+G,QAAQ,CAAC3E,KAAK,CAAC4E,WAAP,CAApB,EAAyC/G,CAAC,GAAG8G,QAAQ,CAAC3E,KAAK,CAAC6E,UAAP,CAArD,EAAyE3G,OAAO,CAACqG,KAAjF,CAAR;UACAG,OAAO,CAAC7E,MAAR;QACD;MACF;IACF;IACD;AACJ;AACA;AACA;AACA;;;IAGI,MAAMnB,UAAU,GAAGsB,KAAK,CAAC8E,QAAN,KAAmB,MAAnB,IAA6B9E,KAAK,CAAC8E,QAAN,KAAmB,QAAnE;IACA,IAAIpG,UAAJ,EAAgBgG,OAAO,CAAC/E,GAAR,CAAY;MAC1B/B,CAAC,EAAEA,CADuB;MAE1BC,CAAC,EAAEA,CAFuB;MAG1BlC,KAAK,EAAEA,KAHmB;MAI1BC,MAAM,EAAEA;IAJkB,CAAZ;;IAOhB,KAAK,IAAIuD,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGjB,OAAO,CAAC6G,UAAR,CAAmBlG,MAAvC,EAA+CM,CAAC,EAAhD,EAAoD;MAClDyC,WAAW,CAAC1D,OAAO,CAAC6G,UAAR,CAAmB5F,CAAnB,CAAD,EAAwBa,KAAxB,CAAX;IACD;;IAED,IAAItB,UAAJ,EAAgBgG,OAAO,CAAC7E,MAAR;EACjB;;EAED,MAAMsC,MAAM,GAAGjE,OAAO,CAAC+D,qBAAR,EAAf;EACA,IAAI+C,MAAM,GAAG1I,QAAQ,CAAC2I,GAAT,CAAa/G,OAAb,CAAb;;EAEA,IAAI8G,MAAM,KAAKpB,SAAf,EAA0B;IACxBoB,MAAM,GAAG5G,QAAQ,CAAC8G,aAAT,CAAuB,QAAvB,CAAT;IACAF,MAAM,CAACrJ,KAAP,GAAewG,MAAM,CAACxG,KAAtB;IACAqJ,MAAM,CAACpJ,MAAP,GAAgBuG,MAAM,CAACvG,MAAvB;IACAU,QAAQ,CAACuH,GAAT,CAAa3F,OAAb,EAAsB8G,MAAtB;EACD;;EAED,MAAMxG,OAAO,GAAGwG,MAAM,CAACG,UAAP,CAAkB;EAClC;EADgB,CAAhB;EAGA,MAAMT,OAAO,GAAG,IAAInG,OAAJ,CAAYC,OAAZ,CAAhB,CA/Q4B,CA+QU;;EAEtCoD,WAAW,CAAC1D,OAAD,CAAX,CAjR4B,CAiRN;;EAEtB,OAAO8G,MAAP;AACD;;AAED,SAAStH,SAAT,CAAmBQ,OAAnB,EAA4BhC,KAA5B,EAAmC0B,CAAnC,EAAsCC,CAAtC,EAAyC;EACvC,MAAMuH,cAAc,GAAG;IACrBC,OAAO,EAAEzH,CAAC,GAAGM,OAAO,CAACoH,WAAZ,GAA0BpH,OAAO,CAACqH,UADtB;IAErBC,OAAO,EAAE3H,CAAC,GAAGK,OAAO,CAACuH,YAAZ,GAA2BvH,OAAO,CAACwH,SAFvB;IAGrBC,IAAI,EAAEzH,OAAO,CAAC0H,aAAR,CAAsBC;EAHP,CAAvB;EAKAlD,MAAM,CAACmD,aAAP,CAAqB,IAAIC,UAAJ,CAAe7J,KAAf,EAAsBkJ,cAAtB,CAArB;EACA,MAAM1F,IAAI,GAAGxB,OAAO,CAAC+D,qBAAR,EAAb;EACArE,CAAC,GAAGA,CAAC,GAAG8B,IAAI,CAAC/D,KAAT,GAAiB+D,IAAI,CAACwC,IAA1B;EACArE,CAAC,GAAGA,CAAC,GAAG6B,IAAI,CAAC9D,MAAT,GAAkB8D,IAAI,CAAC0C,GAA3B;;EAEA,SAAS4D,QAAT,CAAkB9H,OAAlB,EAA2B;IACzB,IAAIA,OAAO,CAAC2D,QAAR,KAAqBC,IAAI,CAACC,SAA1B,IAAuC7D,OAAO,CAAC2D,QAAR,KAAqBC,IAAI,CAACS,YAArE,EAAmF;MACjF,MAAM7C,IAAI,GAAGxB,OAAO,CAAC+D,qBAAR,EAAb;;MAEA,IAAIrE,CAAC,GAAG8B,IAAI,CAACwC,IAAT,IAAiBtE,CAAC,GAAG8B,IAAI,CAACuG,KAA1B,IAAmCpI,CAAC,GAAG6B,IAAI,CAAC0C,GAA5C,IAAmDvE,CAAC,GAAG6B,IAAI,CAACwG,MAAhE,EAAwE;QACtEhI,OAAO,CAAC4H,aAAR,CAAsB,IAAIC,UAAJ,CAAe7J,KAAf,EAAsBkJ,cAAtB,CAAtB;;QAEA,IAAIlH,OAAO,YAAYwF,gBAAnB,IAAuCxF,OAAO,CAACP,IAAR,KAAiB,OAAxD,KAAoEzB,KAAK,KAAK,WAAV,IAAyBA,KAAK,KAAK,OAAvG,CAAJ,EAAqH;UACnH,MAAM,CAACqD,GAAD,EAAMD,GAAN,IAAa,CAAC,KAAD,EAAQ,KAAR,EAAexD,GAAf,CAAmB0I,QAAQ,IAAI7D,UAAU,CAACzC,OAAO,CAACsG,QAAD,CAAR,CAAzC,CAAnB;UACA,MAAM7I,KAAK,GAAG+D,IAAI,CAAC/D,KAAnB;UACA,MAAMwK,OAAO,GAAGvI,CAAC,GAAG8B,IAAI,CAAC9B,CAAzB;UACA,MAAMwI,UAAU,GAAGD,OAAO,GAAGxK,KAA7B;UACAuC,OAAO,CAACqG,KAAR,GAAgBhF,GAAG,GAAG,CAACD,GAAG,GAAGC,GAAP,IAAc6G,UAApC;UACAlI,OAAO,CAAC4H,aAAR,CAAsB,IAAIO,UAAJ,CAAe,OAAf,EAAwB;YAC5CC,OAAO,EAAE;UADmC,CAAxB,CAAtB;QAGD;MACF;;MAED,KAAK,IAAInH,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGjB,OAAO,CAAC6G,UAAR,CAAmBlG,MAAvC,EAA+CM,CAAC,EAAhD,EAAoD;QAClD6G,QAAQ,CAAC9H,OAAO,CAAC6G,UAAR,CAAmB5F,CAAnB,CAAD,CAAR;MACD;IACF;EACF;;EAED6G,QAAQ,CAAC9H,OAAD,CAAR;AACD;;AAED,SAAS9C,QAAT"},"metadata":{},"sourceType":"module"}