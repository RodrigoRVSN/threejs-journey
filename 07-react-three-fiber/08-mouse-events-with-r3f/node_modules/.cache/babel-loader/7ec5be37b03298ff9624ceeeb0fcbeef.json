{"ast":null,"code":"import { Vector3, Vector4, Matrix4, Line3, Box3, Sphere, Mesh, InstancedInterleavedBuffer, InterleavedBufferAttribute, MathUtils } from 'three';\nimport { LineSegmentsGeometry } from './LineSegmentsGeometry.js';\nimport { LineMaterial } from './LineMaterial.js';\n\nconst _start = new Vector3();\n\nconst _end = new Vector3();\n\nconst _start4 = new Vector4();\n\nconst _end4 = new Vector4();\n\nconst _ssOrigin = new Vector4();\n\nconst _ssOrigin3 = new Vector3();\n\nconst _mvMatrix = new Matrix4();\n\nconst _line = new Line3();\n\nconst _closestPoint = new Vector3();\n\nconst _box = new Box3();\n\nconst _sphere = new Sphere();\n\nconst _clipToWorldVector = new Vector4();\n\nlet _ray, _instanceStart, _instanceEnd, _lineWidth; // Returns the margin required to expand by in world space given the distance from the camera,\n// line width, resolution, and camera projection\n\n\nfunction getWorldSpaceHalfWidth(camera, distance, resolution) {\n  // transform into clip space, adjust the x and y values by the pixel width offset, then\n  // transform back into world space to get world offset. Note clip space is [-1, 1] so full\n  // width does not need to be halved.\n  _clipToWorldVector.set(0, 0, -distance, 1.0).applyMatrix4(camera.projectionMatrix);\n\n  _clipToWorldVector.multiplyScalar(1.0 / _clipToWorldVector.w);\n\n  _clipToWorldVector.x = _lineWidth / resolution.width;\n  _clipToWorldVector.y = _lineWidth / resolution.height;\n\n  _clipToWorldVector.applyMatrix4(camera.projectionMatrixInverse);\n\n  _clipToWorldVector.multiplyScalar(1.0 / _clipToWorldVector.w);\n\n  return Math.abs(Math.max(_clipToWorldVector.x, _clipToWorldVector.y));\n}\n\nfunction raycastWorldUnits(lineSegments, intersects) {\n  for (let i = 0, l = _instanceStart.count; i < l; i++) {\n    _line.start.fromBufferAttribute(_instanceStart, i);\n\n    _line.end.fromBufferAttribute(_instanceEnd, i);\n\n    const pointOnLine = new Vector3();\n    const point = new Vector3();\n\n    _ray.distanceSqToSegment(_line.start, _line.end, point, pointOnLine);\n\n    const isInside = point.distanceTo(pointOnLine) < _lineWidth * 0.5;\n\n    if (isInside) {\n      intersects.push({\n        point,\n        pointOnLine,\n        distance: _ray.origin.distanceTo(point),\n        object: lineSegments,\n        face: null,\n        faceIndex: i,\n        uv: null,\n        uv2: null\n      });\n    }\n  }\n}\n\nfunction raycastScreenSpace(lineSegments, camera, intersects) {\n  const projectionMatrix = camera.projectionMatrix;\n  const material = lineSegments.material;\n  const resolution = material.resolution;\n  const matrixWorld = lineSegments.matrixWorld;\n  const geometry = lineSegments.geometry;\n  const instanceStart = geometry.attributes.instanceStart;\n  const instanceEnd = geometry.attributes.instanceEnd;\n  const near = -camera.near; //\n  // pick a point 1 unit out along the ray to avoid the ray origin\n  // sitting at the camera origin which will cause \"w\" to be 0 when\n  // applying the projection matrix.\n\n  _ray.at(1, _ssOrigin); // ndc space [ - 1.0, 1.0 ]\n\n\n  _ssOrigin.w = 1;\n\n  _ssOrigin.applyMatrix4(camera.matrixWorldInverse);\n\n  _ssOrigin.applyMatrix4(projectionMatrix);\n\n  _ssOrigin.multiplyScalar(1 / _ssOrigin.w); // screen space\n\n\n  _ssOrigin.x *= resolution.x / 2;\n  _ssOrigin.y *= resolution.y / 2;\n  _ssOrigin.z = 0;\n\n  _ssOrigin3.copy(_ssOrigin);\n\n  _mvMatrix.multiplyMatrices(camera.matrixWorldInverse, matrixWorld);\n\n  for (let i = 0, l = instanceStart.count; i < l; i++) {\n    _start4.fromBufferAttribute(instanceStart, i);\n\n    _end4.fromBufferAttribute(instanceEnd, i);\n\n    _start4.w = 1;\n    _end4.w = 1; // camera space\n\n    _start4.applyMatrix4(_mvMatrix);\n\n    _end4.applyMatrix4(_mvMatrix); // skip the segment if it's entirely behind the camera\n\n\n    const isBehindCameraNear = _start4.z > near && _end4.z > near;\n\n    if (isBehindCameraNear) {\n      continue;\n    } // trim the segment if it extends behind camera near\n\n\n    if (_start4.z > near) {\n      const deltaDist = _start4.z - _end4.z;\n      const t = (_start4.z - near) / deltaDist;\n\n      _start4.lerp(_end4, t);\n    } else if (_end4.z > near) {\n      const deltaDist = _end4.z - _start4.z;\n      const t = (_end4.z - near) / deltaDist;\n\n      _end4.lerp(_start4, t);\n    } // clip space\n\n\n    _start4.applyMatrix4(projectionMatrix);\n\n    _end4.applyMatrix4(projectionMatrix); // ndc space [ - 1.0, 1.0 ]\n\n\n    _start4.multiplyScalar(1 / _start4.w);\n\n    _end4.multiplyScalar(1 / _end4.w); // screen space\n\n\n    _start4.x *= resolution.x / 2;\n    _start4.y *= resolution.y / 2;\n    _end4.x *= resolution.x / 2;\n    _end4.y *= resolution.y / 2; // create 2d segment\n\n    _line.start.copy(_start4);\n\n    _line.start.z = 0;\n\n    _line.end.copy(_end4);\n\n    _line.end.z = 0; // get closest point on ray to segment\n\n    const param = _line.closestPointToPointParameter(_ssOrigin3, true);\n\n    _line.at(param, _closestPoint); // check if the intersection point is within clip space\n\n\n    const zPos = MathUtils.lerp(_start4.z, _end4.z, param);\n    const isInClipSpace = zPos >= -1 && zPos <= 1;\n\n    const isInside = _ssOrigin3.distanceTo(_closestPoint) < _lineWidth * 0.5;\n\n    if (isInClipSpace && isInside) {\n      _line.start.fromBufferAttribute(instanceStart, i);\n\n      _line.end.fromBufferAttribute(instanceEnd, i);\n\n      _line.start.applyMatrix4(matrixWorld);\n\n      _line.end.applyMatrix4(matrixWorld);\n\n      const pointOnLine = new Vector3();\n      const point = new Vector3();\n\n      _ray.distanceSqToSegment(_line.start, _line.end, point, pointOnLine);\n\n      intersects.push({\n        point: point,\n        pointOnLine: pointOnLine,\n        distance: _ray.origin.distanceTo(point),\n        object: lineSegments,\n        face: null,\n        faceIndex: i,\n        uv: null,\n        uv2: null\n      });\n    }\n  }\n}\n\nclass LineSegments2 extends Mesh {\n  constructor() {\n    let geometry = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new LineSegmentsGeometry();\n    let material = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new LineMaterial({\n      color: Math.random() * 0xffffff\n    });\n    super(geometry, material);\n    this.isLineSegments2 = true;\n    this.type = 'LineSegments2';\n  } // for backwards-compatibility, but could be a method of LineSegmentsGeometry...\n\n\n  computeLineDistances() {\n    const geometry = this.geometry;\n    const instanceStart = geometry.attributes.instanceStart;\n    const instanceEnd = geometry.attributes.instanceEnd;\n    const lineDistances = new Float32Array(2 * instanceStart.count);\n\n    for (let i = 0, j = 0, l = instanceStart.count; i < l; i++, j += 2) {\n      _start.fromBufferAttribute(instanceStart, i);\n\n      _end.fromBufferAttribute(instanceEnd, i);\n\n      lineDistances[j] = j === 0 ? 0 : lineDistances[j - 1];\n      lineDistances[j + 1] = lineDistances[j] + _start.distanceTo(_end);\n    }\n\n    const instanceDistanceBuffer = new InstancedInterleavedBuffer(lineDistances, 2, 1); // d0, d1\n\n    geometry.setAttribute('instanceDistanceStart', new InterleavedBufferAttribute(instanceDistanceBuffer, 1, 0)); // d0\n\n    geometry.setAttribute('instanceDistanceEnd', new InterleavedBufferAttribute(instanceDistanceBuffer, 1, 1)); // d1\n\n    return this;\n  }\n\n  raycast(raycaster, intersects) {\n    const worldUnits = this.material.worldUnits;\n    const camera = raycaster.camera;\n\n    if (camera === null && !worldUnits) {\n      console.error('LineSegments2: \"Raycaster.camera\" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.');\n    }\n\n    const threshold = raycaster.params.Line2 !== undefined ? raycaster.params.Line2.threshold || 0 : 0;\n    _ray = raycaster.ray;\n    const matrixWorld = this.matrixWorld;\n    const geometry = this.geometry;\n    const material = this.material;\n    _lineWidth = material.linewidth + threshold;\n    _instanceStart = geometry.attributes.instanceStart;\n    _instanceEnd = geometry.attributes.instanceEnd; // check if we intersect the sphere bounds\n\n    if (geometry.boundingSphere === null) {\n      geometry.computeBoundingSphere();\n    }\n\n    _sphere.copy(geometry.boundingSphere).applyMatrix4(matrixWorld); // increase the sphere bounds by the worst case line screen space width\n\n\n    let sphereMargin;\n\n    if (worldUnits) {\n      sphereMargin = _lineWidth * 0.5;\n    } else {\n      const distanceToSphere = Math.max(camera.near, _sphere.distanceToPoint(_ray.origin));\n      sphereMargin = getWorldSpaceHalfWidth(camera, distanceToSphere, material.resolution);\n    }\n\n    _sphere.radius += sphereMargin;\n\n    if (_ray.intersectsSphere(_sphere) === false) {\n      return;\n    } // check if we intersect the box bounds\n\n\n    if (geometry.boundingBox === null) {\n      geometry.computeBoundingBox();\n    }\n\n    _box.copy(geometry.boundingBox).applyMatrix4(matrixWorld); // increase the box bounds by the worst case line width\n\n\n    let boxMargin;\n\n    if (worldUnits) {\n      boxMargin = _lineWidth * 0.5;\n    } else {\n      const distanceToBox = Math.max(camera.near, _box.distanceToPoint(_ray.origin));\n      boxMargin = getWorldSpaceHalfWidth(camera, distanceToBox, material.resolution);\n    }\n\n    _box.expandByScalar(boxMargin);\n\n    if (_ray.intersectsBox(_box) === false) {\n      return;\n    }\n\n    if (worldUnits) {\n      raycastWorldUnits(this, intersects);\n    } else {\n      raycastScreenSpace(this, camera, intersects);\n    }\n  }\n\n}\n\nexport { LineSegments2 };","map":{"version":3,"names":["Vector3","Vector4","Matrix4","Line3","Box3","Sphere","Mesh","InstancedInterleavedBuffer","InterleavedBufferAttribute","MathUtils","LineSegmentsGeometry","LineMaterial","_start","_end","_start4","_end4","_ssOrigin","_ssOrigin3","_mvMatrix","_line","_closestPoint","_box","_sphere","_clipToWorldVector","_ray","_instanceStart","_instanceEnd","_lineWidth","getWorldSpaceHalfWidth","camera","distance","resolution","set","applyMatrix4","projectionMatrix","multiplyScalar","w","x","width","y","height","projectionMatrixInverse","Math","abs","max","raycastWorldUnits","lineSegments","intersects","i","l","count","start","fromBufferAttribute","end","pointOnLine","point","distanceSqToSegment","isInside","distanceTo","push","origin","object","face","faceIndex","uv","uv2","raycastScreenSpace","material","matrixWorld","geometry","instanceStart","attributes","instanceEnd","near","at","matrixWorldInverse","z","copy","multiplyMatrices","isBehindCameraNear","deltaDist","t","lerp","param","closestPointToPointParameter","zPos","isInClipSpace","LineSegments2","constructor","color","random","isLineSegments2","type","computeLineDistances","lineDistances","Float32Array","j","instanceDistanceBuffer","setAttribute","raycast","raycaster","worldUnits","console","error","threshold","params","Line2","undefined","ray","linewidth","boundingSphere","computeBoundingSphere","sphereMargin","distanceToSphere","distanceToPoint","radius","intersectsSphere","boundingBox","computeBoundingBox","boxMargin","distanceToBox","expandByScalar","intersectsBox"],"sources":["/home/rodrigorvsn/workspace/study/threejs-journey/07-react-three-fiber/08-mouse-events-with-r3f/node_modules/three-stdlib/lines/LineSegments2.js"],"sourcesContent":["import { Vector3, Vector4, Matrix4, Line3, Box3, Sphere, Mesh, InstancedInterleavedBuffer, InterleavedBufferAttribute, MathUtils } from 'three';\nimport { LineSegmentsGeometry } from './LineSegmentsGeometry.js';\nimport { LineMaterial } from './LineMaterial.js';\n\nconst _start = new Vector3();\n\nconst _end = new Vector3();\n\nconst _start4 = new Vector4();\n\nconst _end4 = new Vector4();\n\nconst _ssOrigin = new Vector4();\n\nconst _ssOrigin3 = new Vector3();\n\nconst _mvMatrix = new Matrix4();\n\nconst _line = new Line3();\n\nconst _closestPoint = new Vector3();\n\nconst _box = new Box3();\n\nconst _sphere = new Sphere();\n\nconst _clipToWorldVector = new Vector4();\n\nlet _ray, _instanceStart, _instanceEnd, _lineWidth; // Returns the margin required to expand by in world space given the distance from the camera,\n// line width, resolution, and camera projection\n\n\nfunction getWorldSpaceHalfWidth(camera, distance, resolution) {\n  // transform into clip space, adjust the x and y values by the pixel width offset, then\n  // transform back into world space to get world offset. Note clip space is [-1, 1] so full\n  // width does not need to be halved.\n  _clipToWorldVector.set(0, 0, -distance, 1.0).applyMatrix4(camera.projectionMatrix);\n\n  _clipToWorldVector.multiplyScalar(1.0 / _clipToWorldVector.w);\n\n  _clipToWorldVector.x = _lineWidth / resolution.width;\n  _clipToWorldVector.y = _lineWidth / resolution.height;\n\n  _clipToWorldVector.applyMatrix4(camera.projectionMatrixInverse);\n\n  _clipToWorldVector.multiplyScalar(1.0 / _clipToWorldVector.w);\n\n  return Math.abs(Math.max(_clipToWorldVector.x, _clipToWorldVector.y));\n}\n\nfunction raycastWorldUnits(lineSegments, intersects) {\n  for (let i = 0, l = _instanceStart.count; i < l; i++) {\n    _line.start.fromBufferAttribute(_instanceStart, i);\n\n    _line.end.fromBufferAttribute(_instanceEnd, i);\n\n    const pointOnLine = new Vector3();\n    const point = new Vector3();\n\n    _ray.distanceSqToSegment(_line.start, _line.end, point, pointOnLine);\n\n    const isInside = point.distanceTo(pointOnLine) < _lineWidth * 0.5;\n\n    if (isInside) {\n      intersects.push({\n        point,\n        pointOnLine,\n        distance: _ray.origin.distanceTo(point),\n        object: lineSegments,\n        face: null,\n        faceIndex: i,\n        uv: null,\n        uv2: null\n      });\n    }\n  }\n}\n\nfunction raycastScreenSpace(lineSegments, camera, intersects) {\n  const projectionMatrix = camera.projectionMatrix;\n  const material = lineSegments.material;\n  const resolution = material.resolution;\n  const matrixWorld = lineSegments.matrixWorld;\n  const geometry = lineSegments.geometry;\n  const instanceStart = geometry.attributes.instanceStart;\n  const instanceEnd = geometry.attributes.instanceEnd;\n  const near = -camera.near; //\n  // pick a point 1 unit out along the ray to avoid the ray origin\n  // sitting at the camera origin which will cause \"w\" to be 0 when\n  // applying the projection matrix.\n\n  _ray.at(1, _ssOrigin); // ndc space [ - 1.0, 1.0 ]\n\n\n  _ssOrigin.w = 1;\n\n  _ssOrigin.applyMatrix4(camera.matrixWorldInverse);\n\n  _ssOrigin.applyMatrix4(projectionMatrix);\n\n  _ssOrigin.multiplyScalar(1 / _ssOrigin.w); // screen space\n\n\n  _ssOrigin.x *= resolution.x / 2;\n  _ssOrigin.y *= resolution.y / 2;\n  _ssOrigin.z = 0;\n\n  _ssOrigin3.copy(_ssOrigin);\n\n  _mvMatrix.multiplyMatrices(camera.matrixWorldInverse, matrixWorld);\n\n  for (let i = 0, l = instanceStart.count; i < l; i++) {\n    _start4.fromBufferAttribute(instanceStart, i);\n\n    _end4.fromBufferAttribute(instanceEnd, i);\n\n    _start4.w = 1;\n    _end4.w = 1; // camera space\n\n    _start4.applyMatrix4(_mvMatrix);\n\n    _end4.applyMatrix4(_mvMatrix); // skip the segment if it's entirely behind the camera\n\n\n    const isBehindCameraNear = _start4.z > near && _end4.z > near;\n\n    if (isBehindCameraNear) {\n      continue;\n    } // trim the segment if it extends behind camera near\n\n\n    if (_start4.z > near) {\n      const deltaDist = _start4.z - _end4.z;\n      const t = (_start4.z - near) / deltaDist;\n\n      _start4.lerp(_end4, t);\n    } else if (_end4.z > near) {\n      const deltaDist = _end4.z - _start4.z;\n      const t = (_end4.z - near) / deltaDist;\n\n      _end4.lerp(_start4, t);\n    } // clip space\n\n\n    _start4.applyMatrix4(projectionMatrix);\n\n    _end4.applyMatrix4(projectionMatrix); // ndc space [ - 1.0, 1.0 ]\n\n\n    _start4.multiplyScalar(1 / _start4.w);\n\n    _end4.multiplyScalar(1 / _end4.w); // screen space\n\n\n    _start4.x *= resolution.x / 2;\n    _start4.y *= resolution.y / 2;\n    _end4.x *= resolution.x / 2;\n    _end4.y *= resolution.y / 2; // create 2d segment\n\n    _line.start.copy(_start4);\n\n    _line.start.z = 0;\n\n    _line.end.copy(_end4);\n\n    _line.end.z = 0; // get closest point on ray to segment\n\n    const param = _line.closestPointToPointParameter(_ssOrigin3, true);\n\n    _line.at(param, _closestPoint); // check if the intersection point is within clip space\n\n\n    const zPos = MathUtils.lerp(_start4.z, _end4.z, param);\n    const isInClipSpace = zPos >= -1 && zPos <= 1;\n\n    const isInside = _ssOrigin3.distanceTo(_closestPoint) < _lineWidth * 0.5;\n\n    if (isInClipSpace && isInside) {\n      _line.start.fromBufferAttribute(instanceStart, i);\n\n      _line.end.fromBufferAttribute(instanceEnd, i);\n\n      _line.start.applyMatrix4(matrixWorld);\n\n      _line.end.applyMatrix4(matrixWorld);\n\n      const pointOnLine = new Vector3();\n      const point = new Vector3();\n\n      _ray.distanceSqToSegment(_line.start, _line.end, point, pointOnLine);\n\n      intersects.push({\n        point: point,\n        pointOnLine: pointOnLine,\n        distance: _ray.origin.distanceTo(point),\n        object: lineSegments,\n        face: null,\n        faceIndex: i,\n        uv: null,\n        uv2: null\n      });\n    }\n  }\n}\n\nclass LineSegments2 extends Mesh {\n  constructor(geometry = new LineSegmentsGeometry(), material = new LineMaterial({\n    color: Math.random() * 0xffffff\n  })) {\n    super(geometry, material);\n    this.isLineSegments2 = true;\n    this.type = 'LineSegments2';\n  } // for backwards-compatibility, but could be a method of LineSegmentsGeometry...\n\n\n  computeLineDistances() {\n    const geometry = this.geometry;\n    const instanceStart = geometry.attributes.instanceStart;\n    const instanceEnd = geometry.attributes.instanceEnd;\n    const lineDistances = new Float32Array(2 * instanceStart.count);\n\n    for (let i = 0, j = 0, l = instanceStart.count; i < l; i++, j += 2) {\n      _start.fromBufferAttribute(instanceStart, i);\n\n      _end.fromBufferAttribute(instanceEnd, i);\n\n      lineDistances[j] = j === 0 ? 0 : lineDistances[j - 1];\n      lineDistances[j + 1] = lineDistances[j] + _start.distanceTo(_end);\n    }\n\n    const instanceDistanceBuffer = new InstancedInterleavedBuffer(lineDistances, 2, 1); // d0, d1\n\n    geometry.setAttribute('instanceDistanceStart', new InterleavedBufferAttribute(instanceDistanceBuffer, 1, 0)); // d0\n\n    geometry.setAttribute('instanceDistanceEnd', new InterleavedBufferAttribute(instanceDistanceBuffer, 1, 1)); // d1\n\n    return this;\n  }\n\n  raycast(raycaster, intersects) {\n    const worldUnits = this.material.worldUnits;\n    const camera = raycaster.camera;\n\n    if (camera === null && !worldUnits) {\n      console.error('LineSegments2: \"Raycaster.camera\" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.');\n    }\n\n    const threshold = raycaster.params.Line2 !== undefined ? raycaster.params.Line2.threshold || 0 : 0;\n    _ray = raycaster.ray;\n    const matrixWorld = this.matrixWorld;\n    const geometry = this.geometry;\n    const material = this.material;\n    _lineWidth = material.linewidth + threshold;\n    _instanceStart = geometry.attributes.instanceStart;\n    _instanceEnd = geometry.attributes.instanceEnd; // check if we intersect the sphere bounds\n\n    if (geometry.boundingSphere === null) {\n      geometry.computeBoundingSphere();\n    }\n\n    _sphere.copy(geometry.boundingSphere).applyMatrix4(matrixWorld); // increase the sphere bounds by the worst case line screen space width\n\n\n    let sphereMargin;\n\n    if (worldUnits) {\n      sphereMargin = _lineWidth * 0.5;\n    } else {\n      const distanceToSphere = Math.max(camera.near, _sphere.distanceToPoint(_ray.origin));\n      sphereMargin = getWorldSpaceHalfWidth(camera, distanceToSphere, material.resolution);\n    }\n\n    _sphere.radius += sphereMargin;\n\n    if (_ray.intersectsSphere(_sphere) === false) {\n      return;\n    } // check if we intersect the box bounds\n\n\n    if (geometry.boundingBox === null) {\n      geometry.computeBoundingBox();\n    }\n\n    _box.copy(geometry.boundingBox).applyMatrix4(matrixWorld); // increase the box bounds by the worst case line width\n\n\n    let boxMargin;\n\n    if (worldUnits) {\n      boxMargin = _lineWidth * 0.5;\n    } else {\n      const distanceToBox = Math.max(camera.near, _box.distanceToPoint(_ray.origin));\n      boxMargin = getWorldSpaceHalfWidth(camera, distanceToBox, material.resolution);\n    }\n\n    _box.expandByScalar(boxMargin);\n\n    if (_ray.intersectsBox(_box) === false) {\n      return;\n    }\n\n    if (worldUnits) {\n      raycastWorldUnits(this, intersects);\n    } else {\n      raycastScreenSpace(this, camera, intersects);\n    }\n  }\n\n}\n\nexport { LineSegments2 };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}