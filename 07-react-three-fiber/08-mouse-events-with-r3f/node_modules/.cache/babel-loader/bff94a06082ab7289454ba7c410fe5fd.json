{"ast":null,"code":"import _extends from '@babel/runtime/helpers/esm/extends';\nimport * as THREE from 'three';\nimport * as React from 'react';\nimport { extend, useThree, useFrame } from '@react-three/fiber';\nimport { shaderMaterial } from './shaderMaterial.js';\n\nfunction isLight(object) {\n  return object.isLight;\n}\n\nfunction isGeometry(object) {\n  return !!object.geometry;\n}\n\nconst accumulativeContext = /*#__PURE__*/React.createContext(null);\nconst SoftShadowMaterial = shaderMaterial({\n  color: new THREE.Color(),\n  blend: 2.0,\n  alphaTest: 0.75,\n  opacity: 0,\n  map: null\n}, `varying vec2 vUv;\n   void main() {\n     gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.);\n     vUv = uv;\n   }`, `varying vec2 vUv;\n   uniform sampler2D map;\n   uniform vec3 color;\n   uniform float opacity;\n   uniform float alphaTest;\n   uniform float blend;\n   void main() {\n     vec4 sampledDiffuseColor = texture2D(map, vUv);\n     gl_FragColor = vec4(color * sampledDiffuseColor.r * blend, max(0.0, (1.0 - (sampledDiffuseColor.r + sampledDiffuseColor.g + sampledDiffuseColor.b) / alphaTest)) * opacity);\n     #include <tonemapping_fragment>\n     #include <encodings_fragment>\n   }`);\nconst DiscardMaterial = shaderMaterial({}, 'void main() { gl_Position = vec4((uv - 0.5) * 2.0, 1.0, 1.0); }', 'void main() { discard; }');\nconst AccumulativeShadows = /*#__PURE__*/React.forwardRef((_ref, forwardRef) => {\n  let {\n    children,\n    temporal,\n    frames = 40,\n    limit = Infinity,\n    blend = 20,\n    scale = 10,\n    opacity = 1,\n    alphaTest = 0.75,\n    color = 'black',\n    colorBlend = 2,\n    resolution = 1024,\n    toneMapped = true,\n    ...props\n  } = _ref;\n  extend({\n    SoftShadowMaterial\n  });\n  const gl = useThree(state => state.gl);\n  const scene = useThree(state => state.scene);\n  const camera = useThree(state => state.camera);\n  const gPlane = React.useRef(null);\n  const gLights = React.useRef(null);\n  const [plm] = React.useState(() => new ProgressiveLightMap(gl, scene, resolution));\n  React.useLayoutEffect(() => {\n    plm.configure(gPlane.current);\n  }, []);\n  const api = React.useMemo(() => ({\n    lights: new Map(),\n    temporal: !!temporal,\n    frames: Math.max(2, frames),\n    blend: Math.max(2, frames === Infinity ? blend : frames),\n    count: 0,\n    getMesh: () => gPlane.current,\n    reset: () => {\n      // Clear buffers, reset opacities, set frame count to 0\n      plm.clear();\n      const material = gPlane.current.material;\n      material.opacity = 0;\n      material.alphaTest = 0;\n      api.count = 0;\n    },\n    update: function () {\n      let frames = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n      // Adapt the opacity-blend ratio to the number of frames\n      const material = gPlane.current.material;\n\n      if (!api.temporal) {\n        material.opacity = opacity;\n        material.alphaTest = alphaTest;\n      } else {\n        material.opacity = Math.min(opacity, material.opacity + opacity / api.blend);\n        material.alphaTest = Math.min(alphaTest, material.alphaTest + alphaTest / api.blend);\n      } // Switch accumulative lights on\n\n\n      gLights.current.visible = true; // Collect scene lights and meshes\n\n      plm.prepare(); // Update the lightmap and the accumulative lights\n\n      for (let i = 0; i < frames; i++) {\n        api.lights.forEach(light => light.update());\n        plm.update(camera, api.blend);\n      } // Switch lights off\n\n\n      gLights.current.visible = false; // Restore lights and meshes\n\n      plm.finish();\n    }\n  }), [plm, camera, scene, temporal, frames, blend, opacity, alphaTest]);\n  React.useLayoutEffect(() => {\n    // Reset internals, buffers, ...\n    api.reset(); // Update lightmap\n\n    if (!api.temporal && api.frames !== Infinity) api.update(api.blend);\n  }); // Expose api, allow children to set itself as the main light source\n\n  React.useImperativeHandle(forwardRef, () => api, [api]);\n  useFrame(() => {\n    if ((api.temporal || api.frames === Infinity) && api.count < api.frames && api.count < limit) {\n      api.update();\n      api.count++;\n    }\n  });\n  return /*#__PURE__*/React.createElement(\"group\", props, /*#__PURE__*/React.createElement(\"group\", {\n    traverse: () => null,\n    ref: gLights\n  }, /*#__PURE__*/React.createElement(accumulativeContext.Provider, {\n    value: api\n  }, children)), /*#__PURE__*/React.createElement(\"mesh\", {\n    receiveShadow: true,\n    ref: gPlane,\n    scale: scale,\n    rotation: [-Math.PI / 2, 0, 0]\n  }, /*#__PURE__*/React.createElement(\"planeGeometry\", null), /*#__PURE__*/React.createElement(\"softShadowMaterial\", {\n    transparent: true,\n    depthWrite: false,\n    toneMapped: toneMapped,\n    color: color,\n    blend: colorBlend,\n    map: plm.progressiveLightMap2.texture\n  })));\n});\nconst RandomizedLight = /*#__PURE__*/React.forwardRef((_ref2, forwardRef) => {\n  let {\n    castShadow = true,\n    bias = 0.001,\n    mapSize = 512,\n    size = 5,\n    near = 0.5,\n    far = 500,\n    frames = 1,\n    position = [0, 0, 0],\n    radius = 1,\n    amount = 8,\n    intensity = 1,\n    ambient = 0.5,\n    ...props\n  } = _ref2;\n  const gLights = React.useRef(null);\n  const length = new THREE.Vector3(...position).length();\n  const parent = React.useContext(accumulativeContext);\n  const update = React.useCallback(() => {\n    let light;\n\n    if (gLights.current) {\n      for (let l = 0; l < gLights.current.children.length; l++) {\n        light = gLights.current.children[l];\n\n        if (Math.random() > ambient) {\n          light.position.set(position[0] + THREE.MathUtils.randFloatSpread(radius), position[1] + THREE.MathUtils.randFloatSpread(radius), position[2] + THREE.MathUtils.randFloatSpread(radius));\n        } else {\n          let lambda = Math.acos(2 * Math.random() - 1) - Math.PI / 2.0;\n          let phi = 2 * Math.PI * Math.random();\n          light.position.set(Math.cos(lambda) * Math.cos(phi) * length, Math.abs(Math.cos(lambda) * Math.sin(phi) * length), Math.sin(lambda) * length);\n        }\n      }\n    }\n  }, [radius, ambient, length, ...position]);\n  const api = React.useMemo(() => ({\n    update\n  }), [update]);\n  React.useImperativeHandle(forwardRef, () => api, [api]);\n  React.useLayoutEffect(() => {\n    const group = gLights.current;\n    if (parent) parent.lights.set(group.uuid, api);\n    return () => void parent.lights.delete(group.uuid);\n  }, [parent, api]);\n  return /*#__PURE__*/React.createElement(\"group\", _extends({\n    ref: gLights\n  }, props), Array.from({\n    length: amount\n  }, (_, index) => /*#__PURE__*/React.createElement(\"directionalLight\", {\n    key: index,\n    castShadow: castShadow,\n    \"shadow-bias\": bias,\n    \"shadow-mapSize\": [mapSize, mapSize],\n    intensity: intensity / amount\n  }, /*#__PURE__*/React.createElement(\"orthographicCamera\", {\n    attach: \"shadow-camera\",\n    args: [-size, size, size, -size, near, far]\n  }))));\n}); // Based on \"Progressive Light Map Accumulator\", by [zalo](https://github.com/zalo/)\n\nclass ProgressiveLightMap {\n  constructor(renderer, scene) {\n    let res = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1024;\n    this.renderer = renderer;\n    this.res = res;\n    this.scene = scene;\n    this.buffer1Active = false;\n    this.lights = [];\n    this.meshes = [];\n    this.object = null; // Create the Progressive LightMap Texture\n\n    const format = /(Android|iPad|iPhone|iPod)/g.test(navigator.userAgent) ? THREE.HalfFloatType : THREE.FloatType;\n    this.progressiveLightMap1 = new THREE.WebGLRenderTarget(this.res, this.res, {\n      type: format,\n      encoding: renderer.outputEncoding\n    });\n    this.progressiveLightMap2 = new THREE.WebGLRenderTarget(this.res, this.res, {\n      type: format,\n      encoding: renderer.outputEncoding\n    }); // Inject some spicy new logic into a standard phong material\n\n    this.discardMat = new DiscardMaterial();\n    this.targetMat = new THREE.MeshPhongMaterial({\n      shininess: 0\n    });\n    this.previousShadowMap = {\n      value: this.progressiveLightMap1.texture\n    };\n    this.averagingWindow = {\n      value: 100\n    };\n\n    this.targetMat.onBeforeCompile = shader => {\n      // Vertex Shader: Set Vertex Positions to the Unwrapped UV Positions\n      shader.vertexShader = 'varying vec2 vUv;\\n' + shader.vertexShader.slice(0, -1) + 'vUv = uv; gl_Position = vec4((uv - 0.5) * 2.0, 1.0, 1.0); }'; // Fragment Shader: Set Pixels to average in the Previous frame's Shadows\n\n      const bodyStart = shader.fragmentShader.indexOf('void main() {');\n      shader.fragmentShader = shader.fragmentShader.replace('#include <clipping_planes_pars_fragment>', '#include <clipping_planes_pars_fragment>\\n#include <shadowmask_pars_fragment>\\n');\n      shader.fragmentShader = 'varying vec2 vUv;\\n' + shader.fragmentShader.slice(0, bodyStart) + '\tuniform sampler2D previousShadowMap;\\n\tuniform float averagingWindow;\\n' + shader.fragmentShader.slice(bodyStart - 1, -1) + `\\nvec3 texelOld = texture2D(previousShadowMap, vUv).rgb;\n        gl_FragColor.rgb = mix(texelOld, gl_FragColor.rgb, 1.0/averagingWindow);\n      }`; // Set the Previous Frame's Texture Buffer and Averaging Window\n\n      shader.uniforms.previousShadowMap = this.previousShadowMap;\n      shader.uniforms.averagingWindow = this.averagingWindow;\n    };\n  }\n\n  clear() {\n    this.renderer.setRenderTarget(this.progressiveLightMap1);\n    this.renderer.clear();\n    this.renderer.setRenderTarget(this.progressiveLightMap2);\n    this.renderer.clear();\n    this.lights = [];\n    this.meshes = [];\n    this.scene.traverse(object => {\n      if (isGeometry(object)) {\n        this.meshes.push({\n          object,\n          material: object.material\n        });\n      } else if (isLight(object)) {\n        this.lights.push({\n          object,\n          intensity: object.intensity\n        });\n      }\n    });\n  }\n\n  prepare() {\n    this.lights.forEach(light => light.object.intensity = 0);\n    this.meshes.forEach(mesh => mesh.object.material = this.discardMat);\n  }\n\n  finish() {\n    this.lights.forEach(light => light.object.intensity = light.intensity);\n    this.meshes.forEach(mesh => mesh.object.material = mesh.material);\n  }\n\n  configure(object) {\n    this.object = object;\n  }\n\n  update(camera) {\n    let blendWindow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;\n    if (!this.object) return; // Set each object's material to the UV Unwrapped Surface Mapping Version\n\n    this.averagingWindow.value = blendWindow;\n    this.object.material = this.targetMat; // Ping-pong two surface buffers for reading/writing\n\n    const activeMap = this.buffer1Active ? this.progressiveLightMap1 : this.progressiveLightMap2;\n    const inactiveMap = this.buffer1Active ? this.progressiveLightMap2 : this.progressiveLightMap1; // Render the object's surface maps\n\n    const oldBg = this.scene.background;\n    this.scene.background = null;\n    this.renderer.setRenderTarget(activeMap);\n    this.previousShadowMap.value = inactiveMap.texture;\n    this.buffer1Active = !this.buffer1Active;\n    this.renderer.render(this.scene, camera);\n    this.renderer.setRenderTarget(null);\n    this.scene.background = oldBg;\n  }\n\n}\n\nexport { AccumulativeShadows, RandomizedLight, accumulativeContext };","map":{"version":3,"names":["_extends","THREE","React","extend","useThree","useFrame","shaderMaterial","isLight","object","isGeometry","geometry","accumulativeContext","createContext","SoftShadowMaterial","color","Color","blend","alphaTest","opacity","map","DiscardMaterial","AccumulativeShadows","forwardRef","children","temporal","frames","limit","Infinity","scale","colorBlend","resolution","toneMapped","props","gl","state","scene","camera","gPlane","useRef","gLights","plm","useState","ProgressiveLightMap","useLayoutEffect","configure","current","api","useMemo","lights","Map","Math","max","count","getMesh","reset","clear","material","update","min","visible","prepare","i","forEach","light","finish","useImperativeHandle","createElement","traverse","ref","Provider","value","receiveShadow","rotation","PI","transparent","depthWrite","progressiveLightMap2","texture","RandomizedLight","castShadow","bias","mapSize","size","near","far","position","radius","amount","intensity","ambient","length","Vector3","parent","useContext","useCallback","l","random","set","MathUtils","randFloatSpread","lambda","acos","phi","cos","abs","sin","group","uuid","delete","Array","from","_","index","key","attach","args","constructor","renderer","res","buffer1Active","meshes","format","test","navigator","userAgent","HalfFloatType","FloatType","progressiveLightMap1","WebGLRenderTarget","type","encoding","outputEncoding","discardMat","targetMat","MeshPhongMaterial","shininess","previousShadowMap","averagingWindow","onBeforeCompile","shader","vertexShader","slice","bodyStart","fragmentShader","indexOf","replace","uniforms","setRenderTarget","push","mesh","blendWindow","activeMap","inactiveMap","oldBg","background","render"],"sources":["/home/rodrigorvsn/workspace/study/threejs-journey/07-react-three-fiber/08-mouse-events-with-r3f/node_modules/@react-three/drei/core/AccumulativeShadows.js"],"sourcesContent":["import _extends from '@babel/runtime/helpers/esm/extends';\nimport * as THREE from 'three';\nimport * as React from 'react';\nimport { extend, useThree, useFrame } from '@react-three/fiber';\nimport { shaderMaterial } from './shaderMaterial.js';\n\nfunction isLight(object) {\n  return object.isLight;\n}\n\nfunction isGeometry(object) {\n  return !!object.geometry;\n}\n\nconst accumulativeContext = /*#__PURE__*/React.createContext(null);\nconst SoftShadowMaterial = shaderMaterial({\n  color: new THREE.Color(),\n  blend: 2.0,\n  alphaTest: 0.75,\n  opacity: 0,\n  map: null\n}, `varying vec2 vUv;\n   void main() {\n     gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.);\n     vUv = uv;\n   }`, `varying vec2 vUv;\n   uniform sampler2D map;\n   uniform vec3 color;\n   uniform float opacity;\n   uniform float alphaTest;\n   uniform float blend;\n   void main() {\n     vec4 sampledDiffuseColor = texture2D(map, vUv);\n     gl_FragColor = vec4(color * sampledDiffuseColor.r * blend, max(0.0, (1.0 - (sampledDiffuseColor.r + sampledDiffuseColor.g + sampledDiffuseColor.b) / alphaTest)) * opacity);\n     #include <tonemapping_fragment>\n     #include <encodings_fragment>\n   }`);\nconst DiscardMaterial = shaderMaterial({}, 'void main() { gl_Position = vec4((uv - 0.5) * 2.0, 1.0, 1.0); }', 'void main() { discard; }');\nconst AccumulativeShadows = /*#__PURE__*/React.forwardRef(({\n  children,\n  temporal,\n  frames = 40,\n  limit = Infinity,\n  blend = 20,\n  scale = 10,\n  opacity = 1,\n  alphaTest = 0.75,\n  color = 'black',\n  colorBlend = 2,\n  resolution = 1024,\n  toneMapped = true,\n  ...props\n}, forwardRef) => {\n  extend({\n    SoftShadowMaterial\n  });\n  const gl = useThree(state => state.gl);\n  const scene = useThree(state => state.scene);\n  const camera = useThree(state => state.camera);\n  const gPlane = React.useRef(null);\n  const gLights = React.useRef(null);\n  const [plm] = React.useState(() => new ProgressiveLightMap(gl, scene, resolution));\n  React.useLayoutEffect(() => {\n    plm.configure(gPlane.current);\n  }, []);\n  const api = React.useMemo(() => ({\n    lights: new Map(),\n    temporal: !!temporal,\n    frames: Math.max(2, frames),\n    blend: Math.max(2, frames === Infinity ? blend : frames),\n    count: 0,\n    getMesh: () => gPlane.current,\n    reset: () => {\n      // Clear buffers, reset opacities, set frame count to 0\n      plm.clear();\n      const material = gPlane.current.material;\n      material.opacity = 0;\n      material.alphaTest = 0;\n      api.count = 0;\n    },\n    update: (frames = 1) => {\n      // Adapt the opacity-blend ratio to the number of frames\n      const material = gPlane.current.material;\n\n      if (!api.temporal) {\n        material.opacity = opacity;\n        material.alphaTest = alphaTest;\n      } else {\n        material.opacity = Math.min(opacity, material.opacity + opacity / api.blend);\n        material.alphaTest = Math.min(alphaTest, material.alphaTest + alphaTest / api.blend);\n      } // Switch accumulative lights on\n\n\n      gLights.current.visible = true; // Collect scene lights and meshes\n\n      plm.prepare(); // Update the lightmap and the accumulative lights\n\n      for (let i = 0; i < frames; i++) {\n        api.lights.forEach(light => light.update());\n        plm.update(camera, api.blend);\n      } // Switch lights off\n\n\n      gLights.current.visible = false; // Restore lights and meshes\n\n      plm.finish();\n    }\n  }), [plm, camera, scene, temporal, frames, blend, opacity, alphaTest]);\n  React.useLayoutEffect(() => {\n    // Reset internals, buffers, ...\n    api.reset(); // Update lightmap\n\n    if (!api.temporal && api.frames !== Infinity) api.update(api.blend);\n  }); // Expose api, allow children to set itself as the main light source\n\n  React.useImperativeHandle(forwardRef, () => api, [api]);\n  useFrame(() => {\n    if ((api.temporal || api.frames === Infinity) && api.count < api.frames && api.count < limit) {\n      api.update();\n      api.count++;\n    }\n  });\n  return /*#__PURE__*/React.createElement(\"group\", props, /*#__PURE__*/React.createElement(\"group\", {\n    traverse: () => null,\n    ref: gLights\n  }, /*#__PURE__*/React.createElement(accumulativeContext.Provider, {\n    value: api\n  }, children)), /*#__PURE__*/React.createElement(\"mesh\", {\n    receiveShadow: true,\n    ref: gPlane,\n    scale: scale,\n    rotation: [-Math.PI / 2, 0, 0]\n  }, /*#__PURE__*/React.createElement(\"planeGeometry\", null), /*#__PURE__*/React.createElement(\"softShadowMaterial\", {\n    transparent: true,\n    depthWrite: false,\n    toneMapped: toneMapped,\n    color: color,\n    blend: colorBlend,\n    map: plm.progressiveLightMap2.texture\n  })));\n});\nconst RandomizedLight = /*#__PURE__*/React.forwardRef(({\n  castShadow = true,\n  bias = 0.001,\n  mapSize = 512,\n  size = 5,\n  near = 0.5,\n  far = 500,\n  frames = 1,\n  position = [0, 0, 0],\n  radius = 1,\n  amount = 8,\n  intensity = 1,\n  ambient = 0.5,\n  ...props\n}, forwardRef) => {\n  const gLights = React.useRef(null);\n  const length = new THREE.Vector3(...position).length();\n  const parent = React.useContext(accumulativeContext);\n  const update = React.useCallback(() => {\n    let light;\n\n    if (gLights.current) {\n      for (let l = 0; l < gLights.current.children.length; l++) {\n        light = gLights.current.children[l];\n\n        if (Math.random() > ambient) {\n          light.position.set(position[0] + THREE.MathUtils.randFloatSpread(radius), position[1] + THREE.MathUtils.randFloatSpread(radius), position[2] + THREE.MathUtils.randFloatSpread(radius));\n        } else {\n          let lambda = Math.acos(2 * Math.random() - 1) - Math.PI / 2.0;\n          let phi = 2 * Math.PI * Math.random();\n          light.position.set(Math.cos(lambda) * Math.cos(phi) * length, Math.abs(Math.cos(lambda) * Math.sin(phi) * length), Math.sin(lambda) * length);\n        }\n      }\n    }\n  }, [radius, ambient, length, ...position]);\n  const api = React.useMemo(() => ({\n    update\n  }), [update]);\n  React.useImperativeHandle(forwardRef, () => api, [api]);\n  React.useLayoutEffect(() => {\n    const group = gLights.current;\n    if (parent) parent.lights.set(group.uuid, api);\n    return () => void parent.lights.delete(group.uuid);\n  }, [parent, api]);\n  return /*#__PURE__*/React.createElement(\"group\", _extends({\n    ref: gLights\n  }, props), Array.from({\n    length: amount\n  }, (_, index) => /*#__PURE__*/React.createElement(\"directionalLight\", {\n    key: index,\n    castShadow: castShadow,\n    \"shadow-bias\": bias,\n    \"shadow-mapSize\": [mapSize, mapSize],\n    intensity: intensity / amount\n  }, /*#__PURE__*/React.createElement(\"orthographicCamera\", {\n    attach: \"shadow-camera\",\n    args: [-size, size, size, -size, near, far]\n  }))));\n}); // Based on \"Progressive Light Map Accumulator\", by [zalo](https://github.com/zalo/)\n\nclass ProgressiveLightMap {\n  constructor(renderer, scene, res = 1024) {\n    this.renderer = renderer;\n    this.res = res;\n    this.scene = scene;\n    this.buffer1Active = false;\n    this.lights = [];\n    this.meshes = [];\n    this.object = null; // Create the Progressive LightMap Texture\n\n    const format = /(Android|iPad|iPhone|iPod)/g.test(navigator.userAgent) ? THREE.HalfFloatType : THREE.FloatType;\n    this.progressiveLightMap1 = new THREE.WebGLRenderTarget(this.res, this.res, {\n      type: format,\n      encoding: renderer.outputEncoding\n    });\n    this.progressiveLightMap2 = new THREE.WebGLRenderTarget(this.res, this.res, {\n      type: format,\n      encoding: renderer.outputEncoding\n    }); // Inject some spicy new logic into a standard phong material\n\n    this.discardMat = new DiscardMaterial();\n    this.targetMat = new THREE.MeshPhongMaterial({\n      shininess: 0\n    });\n    this.previousShadowMap = {\n      value: this.progressiveLightMap1.texture\n    };\n    this.averagingWindow = {\n      value: 100\n    };\n\n    this.targetMat.onBeforeCompile = shader => {\n      // Vertex Shader: Set Vertex Positions to the Unwrapped UV Positions\n      shader.vertexShader = 'varying vec2 vUv;\\n' + shader.vertexShader.slice(0, -1) + 'vUv = uv; gl_Position = vec4((uv - 0.5) * 2.0, 1.0, 1.0); }'; // Fragment Shader: Set Pixels to average in the Previous frame's Shadows\n\n      const bodyStart = shader.fragmentShader.indexOf('void main() {');\n      shader.fragmentShader = shader.fragmentShader.replace('#include <clipping_planes_pars_fragment>', '#include <clipping_planes_pars_fragment>\\n#include <shadowmask_pars_fragment>\\n');\n      shader.fragmentShader = 'varying vec2 vUv;\\n' + shader.fragmentShader.slice(0, bodyStart) + '\tuniform sampler2D previousShadowMap;\\n\tuniform float averagingWindow;\\n' + shader.fragmentShader.slice(bodyStart - 1, -1) + `\\nvec3 texelOld = texture2D(previousShadowMap, vUv).rgb;\n        gl_FragColor.rgb = mix(texelOld, gl_FragColor.rgb, 1.0/averagingWindow);\n      }`; // Set the Previous Frame's Texture Buffer and Averaging Window\n\n      shader.uniforms.previousShadowMap = this.previousShadowMap;\n      shader.uniforms.averagingWindow = this.averagingWindow;\n    };\n  }\n\n  clear() {\n    this.renderer.setRenderTarget(this.progressiveLightMap1);\n    this.renderer.clear();\n    this.renderer.setRenderTarget(this.progressiveLightMap2);\n    this.renderer.clear();\n    this.lights = [];\n    this.meshes = [];\n    this.scene.traverse(object => {\n      if (isGeometry(object)) {\n        this.meshes.push({\n          object,\n          material: object.material\n        });\n      } else if (isLight(object)) {\n        this.lights.push({\n          object,\n          intensity: object.intensity\n        });\n      }\n    });\n  }\n\n  prepare() {\n    this.lights.forEach(light => light.object.intensity = 0);\n    this.meshes.forEach(mesh => mesh.object.material = this.discardMat);\n  }\n\n  finish() {\n    this.lights.forEach(light => light.object.intensity = light.intensity);\n    this.meshes.forEach(mesh => mesh.object.material = mesh.material);\n  }\n\n  configure(object) {\n    this.object = object;\n  }\n\n  update(camera, blendWindow = 100) {\n    if (!this.object) return; // Set each object's material to the UV Unwrapped Surface Mapping Version\n\n    this.averagingWindow.value = blendWindow;\n    this.object.material = this.targetMat; // Ping-pong two surface buffers for reading/writing\n\n    const activeMap = this.buffer1Active ? this.progressiveLightMap1 : this.progressiveLightMap2;\n    const inactiveMap = this.buffer1Active ? this.progressiveLightMap2 : this.progressiveLightMap1; // Render the object's surface maps\n\n    const oldBg = this.scene.background;\n    this.scene.background = null;\n    this.renderer.setRenderTarget(activeMap);\n    this.previousShadowMap.value = inactiveMap.texture;\n    this.buffer1Active = !this.buffer1Active;\n    this.renderer.render(this.scene, camera);\n    this.renderer.setRenderTarget(null);\n    this.scene.background = oldBg;\n  }\n\n}\n\nexport { AccumulativeShadows, RandomizedLight, accumulativeContext };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}