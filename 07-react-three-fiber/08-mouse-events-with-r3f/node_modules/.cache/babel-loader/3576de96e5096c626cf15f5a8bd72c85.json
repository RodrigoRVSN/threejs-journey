{"ast":null,"code":"import _extends from '@babel/runtime/helpers/esm/extends';\nimport * as THREE from 'three';\nimport * as React from 'react';\nimport { extend, useFrame } from '@react-three/fiber';\nimport mergeRefs from 'react-merge-refs';\n\nconst _inverseMatrix = /*@__PURE__*/new THREE.Matrix4();\n\nconst _ray = /*@__PURE__*/new THREE.Ray();\n\nconst _sphere = /*@__PURE__*/new THREE.Sphere();\n\nconst _position = /*@__PURE__*/new THREE.Vector3();\n\nclass PositionPoint extends THREE.Group {\n  constructor() {\n    super();\n    this.size = 0;\n    this.color = new THREE.Color('white');\n    this.instance = {\n      current: undefined\n    };\n    this.instanceKey = {\n      current: undefined\n    };\n  } // This will allow the virtual instance have bounds\n\n\n  get geometry() {\n    var _this$instance$curren;\n\n    return (_this$instance$curren = this.instance.current) == null ? void 0 : _this$instance$curren.geometry;\n  }\n\n  raycast(raycaster, intersects) {\n    var _raycaster$params$Poi, _raycaster$params$Poi2;\n\n    const parent = this.instance.current;\n    if (!parent || !parent.geometry) return;\n    const instanceId = parent.userData.instances.indexOf(this.instanceKey); // If the instance wasn't found or exceeds the parents draw range, bail out\n\n    if (instanceId === -1 || instanceId > parent.geometry.drawRange.count) return;\n    const threshold = (_raycaster$params$Poi = (_raycaster$params$Poi2 = raycaster.params.Points) == null ? void 0 : _raycaster$params$Poi2.threshold) !== null && _raycaster$params$Poi !== void 0 ? _raycaster$params$Poi : 1;\n\n    _sphere.set(this.getWorldPosition(_position), threshold);\n\n    if (raycaster.ray.intersectsSphere(_sphere) === false) return;\n\n    _inverseMatrix.copy(parent.matrixWorld).invert();\n\n    _ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix);\n\n    const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);\n    const localThresholdSq = localThreshold * localThreshold;\n\n    const rayPointDistanceSq = _ray.distanceSqToPoint(_position);\n\n    if (rayPointDistanceSq < localThresholdSq) {\n      const intersectPoint = new THREE.Vector3();\n\n      _ray.closestPointToPoint(_position, intersectPoint);\n\n      intersectPoint.applyMatrix4(this.matrixWorld);\n      const distance = raycaster.ray.origin.distanceTo(intersectPoint);\n      if (distance < raycaster.near || distance > raycaster.far) return;\n      intersects.push({\n        distance: distance,\n        distanceToRay: Math.sqrt(rayPointDistanceSq),\n        point: intersectPoint,\n        index: instanceId,\n        face: null,\n        object: this\n      });\n    }\n  }\n\n}\n\nlet i, positionRef;\nconst context = /*@__PURE__*/React.createContext(null);\nconst parentMatrix = /*@__PURE__*/new THREE.Matrix4();\nconst position = /*@__PURE__*/new THREE.Vector3();\n/**\n * Instance implementation, relies on react + context to update the attributes based on the children of this component\n */\n\nconst PointsInstances = /*#__PURE__*/React.forwardRef((_ref, ref) => {\n  let {\n    children,\n    range,\n    limit = 1000,\n    ...props\n  } = _ref;\n  const parentRef = React.useRef(null);\n  const [refs, setRefs] = React.useState([]);\n  const [[positions, colors, sizes]] = React.useState(() => [new Float32Array(limit * 3), Float32Array.from({\n    length: limit * 3\n  }, () => 1), Float32Array.from({\n    length: limit\n  }, () => 1)]);\n  React.useEffect(() => {\n    // We might be a frame too late? ðŸ¤·â€â™‚ï¸\n    parentRef.current.geometry.attributes.position.needsUpdate = true;\n  });\n  useFrame(() => {\n    parentRef.current.updateMatrix();\n    parentRef.current.updateMatrixWorld();\n    parentMatrix.copy(parentRef.current.matrixWorld).invert();\n    parentRef.current.geometry.drawRange.count = Math.min(limit, range !== undefined ? range : limit, refs.length);\n\n    for (i = 0; i < refs.length; i++) {\n      positionRef = refs[i].current;\n      positionRef.getWorldPosition(position).applyMatrix4(parentMatrix);\n      position.toArray(positions, i * 3);\n      parentRef.current.geometry.attributes.position.needsUpdate = true;\n      positionRef.matrixWorldNeedsUpdate = true;\n      positionRef.color.toArray(colors, i * 3);\n      parentRef.current.geometry.attributes.color.needsUpdate = true;\n      sizes.set([positionRef.size], i);\n      parentRef.current.geometry.attributes.size.needsUpdate = true;\n    }\n  });\n  const api = React.useMemo(() => ({\n    getParent: () => parentRef,\n    subscribe: ref => {\n      setRefs(refs => [...refs, ref]);\n      return () => setRefs(refs => refs.filter(item => item.current !== ref.current));\n    }\n  }), []);\n  return /*#__PURE__*/React.createElement(\"points\", _extends({\n    userData: {\n      instances: refs\n    },\n    matrixAutoUpdate: false,\n    ref: mergeRefs([ref, parentRef]),\n    raycast: () => null\n  }, props), /*#__PURE__*/React.createElement(\"bufferGeometry\", null, /*#__PURE__*/React.createElement(\"bufferAttribute\", {\n    attach: \"attributes-position\",\n    count: positions.length / 3,\n    array: positions,\n    itemSize: 3,\n    usage: THREE.DynamicDrawUsage\n  }), /*#__PURE__*/React.createElement(\"bufferAttribute\", {\n    attach: \"attributes-color\",\n    count: colors.length / 3,\n    array: colors,\n    itemSize: 3,\n    usage: THREE.DynamicDrawUsage\n  }), /*#__PURE__*/React.createElement(\"bufferAttribute\", {\n    attach: \"attributes-size\",\n    count: sizes.length,\n    array: sizes,\n    itemSize: 1,\n    usage: THREE.DynamicDrawUsage\n  })), /*#__PURE__*/React.createElement(context.Provider, {\n    value: api\n  }, children));\n});\nconst Point = /*#__PURE__*/React.forwardRef((_ref2, ref) => {\n  let {\n    children,\n    ...props\n  } = _ref2;\n  React.useMemo(() => extend({\n    PositionPoint\n  }), []);\n  const group = React.useRef();\n  const {\n    subscribe,\n    getParent\n  } = React.useContext(context);\n  React.useLayoutEffect(() => subscribe(group), []);\n  return /*#__PURE__*/React.createElement(\"positionPoint\", _extends({\n    instance: getParent(),\n    instanceKey: group,\n    ref: mergeRefs([ref, group])\n  }, props), children);\n});\n/**\n * Buffer implementation, relies on complete buffers of the correct number, leaves it to the user to update them\n */\n\nconst PointsBuffer = /*#__PURE__*/React.forwardRef((_ref3, forwardedRef) => {\n  let {\n    children,\n    positions,\n    colors,\n    sizes,\n    stride = 3,\n    ...props\n  } = _ref3;\n  const pointsRef = React.useRef(null);\n  useFrame(() => {\n    const attr = pointsRef.current.geometry.attributes;\n    attr.position.needsUpdate = true;\n    if (colors) attr.color.needsUpdate = true;\n    if (sizes) attr.size.needsUpdate = true;\n  });\n  return /*#__PURE__*/React.createElement(\"points\", _extends({\n    ref: mergeRefs([forwardedRef, pointsRef])\n  }, props), /*#__PURE__*/React.createElement(\"bufferGeometry\", null, /*#__PURE__*/React.createElement(\"bufferAttribute\", {\n    attach: \"attributes-position\",\n    count: positions.length / stride,\n    array: positions,\n    itemSize: stride,\n    usage: THREE.DynamicDrawUsage\n  }), colors && /*#__PURE__*/React.createElement(\"bufferAttribute\", {\n    attach: \"attributes-color\",\n    count: colors.length / stride,\n    array: colors,\n    itemSize: 3,\n    usage: THREE.DynamicDrawUsage\n  }), sizes && /*#__PURE__*/React.createElement(\"bufferAttribute\", {\n    attach: \"attributes-size\",\n    count: sizes.length / stride,\n    array: sizes,\n    itemSize: 1,\n    usage: THREE.DynamicDrawUsage\n  })), children);\n});\nconst Points = /*#__PURE__*/React.forwardRef((props, forwardedRef) => {\n  if (props.positions instanceof Float32Array) {\n    return /*#__PURE__*/React.createElement(PointsBuffer, _extends({}, props, {\n      ref: forwardedRef\n    }));\n  } else return /*#__PURE__*/React.createElement(PointsInstances, _extends({}, props, {\n    ref: forwardedRef\n  }));\n});\nexport { Point, Points, PointsBuffer, PositionPoint };","map":{"version":3,"names":["_extends","THREE","React","extend","useFrame","mergeRefs","_inverseMatrix","Matrix4","_ray","Ray","_sphere","Sphere","_position","Vector3","PositionPoint","Group","constructor","size","color","Color","instance","current","undefined","instanceKey","geometry","_this$instance$curren","raycast","raycaster","intersects","_raycaster$params$Poi","_raycaster$params$Poi2","parent","instanceId","userData","instances","indexOf","drawRange","count","threshold","params","Points","set","getWorldPosition","ray","intersectsSphere","copy","matrixWorld","invert","applyMatrix4","localThreshold","scale","x","y","z","localThresholdSq","rayPointDistanceSq","distanceSqToPoint","intersectPoint","closestPointToPoint","distance","origin","distanceTo","near","far","push","distanceToRay","Math","sqrt","point","index","face","object","i","positionRef","context","createContext","parentMatrix","position","PointsInstances","forwardRef","ref","children","range","limit","props","parentRef","useRef","refs","setRefs","useState","positions","colors","sizes","Float32Array","from","length","useEffect","attributes","needsUpdate","updateMatrix","updateMatrixWorld","min","toArray","matrixWorldNeedsUpdate","api","useMemo","getParent","subscribe","filter","item","createElement","matrixAutoUpdate","attach","array","itemSize","usage","DynamicDrawUsage","Provider","value","Point","group","useContext","useLayoutEffect","PointsBuffer","forwardedRef","stride","pointsRef","attr"],"sources":["/home/rodrigorvsn/workspace/study/threejs-journey/07-react-three-fiber/08-mouse-events-with-r3f/node_modules/@react-three/drei/core/Points.js"],"sourcesContent":["import _extends from '@babel/runtime/helpers/esm/extends';\nimport * as THREE from 'three';\nimport * as React from 'react';\nimport { extend, useFrame } from '@react-three/fiber';\nimport mergeRefs from 'react-merge-refs';\n\nconst _inverseMatrix = /*@__PURE__*/new THREE.Matrix4();\n\nconst _ray = /*@__PURE__*/new THREE.Ray();\n\nconst _sphere = /*@__PURE__*/new THREE.Sphere();\n\nconst _position = /*@__PURE__*/new THREE.Vector3();\n\nclass PositionPoint extends THREE.Group {\n  constructor() {\n    super();\n    this.size = 0;\n    this.color = new THREE.Color('white');\n    this.instance = {\n      current: undefined\n    };\n    this.instanceKey = {\n      current: undefined\n    };\n  } // This will allow the virtual instance have bounds\n\n\n  get geometry() {\n    var _this$instance$curren;\n\n    return (_this$instance$curren = this.instance.current) == null ? void 0 : _this$instance$curren.geometry;\n  }\n\n  raycast(raycaster, intersects) {\n    var _raycaster$params$Poi, _raycaster$params$Poi2;\n\n    const parent = this.instance.current;\n    if (!parent || !parent.geometry) return;\n    const instanceId = parent.userData.instances.indexOf(this.instanceKey); // If the instance wasn't found or exceeds the parents draw range, bail out\n\n    if (instanceId === -1 || instanceId > parent.geometry.drawRange.count) return;\n    const threshold = (_raycaster$params$Poi = (_raycaster$params$Poi2 = raycaster.params.Points) == null ? void 0 : _raycaster$params$Poi2.threshold) !== null && _raycaster$params$Poi !== void 0 ? _raycaster$params$Poi : 1;\n\n    _sphere.set(this.getWorldPosition(_position), threshold);\n\n    if (raycaster.ray.intersectsSphere(_sphere) === false) return;\n\n    _inverseMatrix.copy(parent.matrixWorld).invert();\n\n    _ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix);\n\n    const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);\n    const localThresholdSq = localThreshold * localThreshold;\n\n    const rayPointDistanceSq = _ray.distanceSqToPoint(_position);\n\n    if (rayPointDistanceSq < localThresholdSq) {\n      const intersectPoint = new THREE.Vector3();\n\n      _ray.closestPointToPoint(_position, intersectPoint);\n\n      intersectPoint.applyMatrix4(this.matrixWorld);\n      const distance = raycaster.ray.origin.distanceTo(intersectPoint);\n      if (distance < raycaster.near || distance > raycaster.far) return;\n      intersects.push({\n        distance: distance,\n        distanceToRay: Math.sqrt(rayPointDistanceSq),\n        point: intersectPoint,\n        index: instanceId,\n        face: null,\n        object: this\n      });\n    }\n  }\n\n}\nlet i, positionRef;\nconst context = /*@__PURE__*/React.createContext(null);\nconst parentMatrix = /*@__PURE__*/new THREE.Matrix4();\nconst position = /*@__PURE__*/new THREE.Vector3();\n/**\n * Instance implementation, relies on react + context to update the attributes based on the children of this component\n */\n\nconst PointsInstances = /*#__PURE__*/React.forwardRef(({\n  children,\n  range,\n  limit = 1000,\n  ...props\n}, ref) => {\n  const parentRef = React.useRef(null);\n  const [refs, setRefs] = React.useState([]);\n  const [[positions, colors, sizes]] = React.useState(() => [new Float32Array(limit * 3), Float32Array.from({\n    length: limit * 3\n  }, () => 1), Float32Array.from({\n    length: limit\n  }, () => 1)]);\n  React.useEffect(() => {\n    // We might be a frame too late? ðŸ¤·â€â™‚ï¸\n    parentRef.current.geometry.attributes.position.needsUpdate = true;\n  });\n  useFrame(() => {\n    parentRef.current.updateMatrix();\n    parentRef.current.updateMatrixWorld();\n    parentMatrix.copy(parentRef.current.matrixWorld).invert();\n    parentRef.current.geometry.drawRange.count = Math.min(limit, range !== undefined ? range : limit, refs.length);\n\n    for (i = 0; i < refs.length; i++) {\n      positionRef = refs[i].current;\n      positionRef.getWorldPosition(position).applyMatrix4(parentMatrix);\n      position.toArray(positions, i * 3);\n      parentRef.current.geometry.attributes.position.needsUpdate = true;\n      positionRef.matrixWorldNeedsUpdate = true;\n      positionRef.color.toArray(colors, i * 3);\n      parentRef.current.geometry.attributes.color.needsUpdate = true;\n      sizes.set([positionRef.size], i);\n      parentRef.current.geometry.attributes.size.needsUpdate = true;\n    }\n  });\n  const api = React.useMemo(() => ({\n    getParent: () => parentRef,\n    subscribe: ref => {\n      setRefs(refs => [...refs, ref]);\n      return () => setRefs(refs => refs.filter(item => item.current !== ref.current));\n    }\n  }), []);\n  return /*#__PURE__*/React.createElement(\"points\", _extends({\n    userData: {\n      instances: refs\n    },\n    matrixAutoUpdate: false,\n    ref: mergeRefs([ref, parentRef]),\n    raycast: () => null\n  }, props), /*#__PURE__*/React.createElement(\"bufferGeometry\", null, /*#__PURE__*/React.createElement(\"bufferAttribute\", {\n    attach: \"attributes-position\",\n    count: positions.length / 3,\n    array: positions,\n    itemSize: 3,\n    usage: THREE.DynamicDrawUsage\n  }), /*#__PURE__*/React.createElement(\"bufferAttribute\", {\n    attach: \"attributes-color\",\n    count: colors.length / 3,\n    array: colors,\n    itemSize: 3,\n    usage: THREE.DynamicDrawUsage\n  }), /*#__PURE__*/React.createElement(\"bufferAttribute\", {\n    attach: \"attributes-size\",\n    count: sizes.length,\n    array: sizes,\n    itemSize: 1,\n    usage: THREE.DynamicDrawUsage\n  })), /*#__PURE__*/React.createElement(context.Provider, {\n    value: api\n  }, children));\n});\nconst Point = /*#__PURE__*/React.forwardRef(({\n  children,\n  ...props\n}, ref) => {\n  React.useMemo(() => extend({\n    PositionPoint\n  }), []);\n  const group = React.useRef();\n  const {\n    subscribe,\n    getParent\n  } = React.useContext(context);\n  React.useLayoutEffect(() => subscribe(group), []);\n  return /*#__PURE__*/React.createElement(\"positionPoint\", _extends({\n    instance: getParent(),\n    instanceKey: group,\n    ref: mergeRefs([ref, group])\n  }, props), children);\n});\n/**\n * Buffer implementation, relies on complete buffers of the correct number, leaves it to the user to update them\n */\n\nconst PointsBuffer = /*#__PURE__*/React.forwardRef(({\n  children,\n  positions,\n  colors,\n  sizes,\n  stride = 3,\n  ...props\n}, forwardedRef) => {\n  const pointsRef = React.useRef(null);\n  useFrame(() => {\n    const attr = pointsRef.current.geometry.attributes;\n    attr.position.needsUpdate = true;\n    if (colors) attr.color.needsUpdate = true;\n    if (sizes) attr.size.needsUpdate = true;\n  });\n  return /*#__PURE__*/React.createElement(\"points\", _extends({\n    ref: mergeRefs([forwardedRef, pointsRef])\n  }, props), /*#__PURE__*/React.createElement(\"bufferGeometry\", null, /*#__PURE__*/React.createElement(\"bufferAttribute\", {\n    attach: \"attributes-position\",\n    count: positions.length / stride,\n    array: positions,\n    itemSize: stride,\n    usage: THREE.DynamicDrawUsage\n  }), colors && /*#__PURE__*/React.createElement(\"bufferAttribute\", {\n    attach: \"attributes-color\",\n    count: colors.length / stride,\n    array: colors,\n    itemSize: 3,\n    usage: THREE.DynamicDrawUsage\n  }), sizes && /*#__PURE__*/React.createElement(\"bufferAttribute\", {\n    attach: \"attributes-size\",\n    count: sizes.length / stride,\n    array: sizes,\n    itemSize: 1,\n    usage: THREE.DynamicDrawUsage\n  })), children);\n});\nconst Points = /*#__PURE__*/React.forwardRef((props, forwardedRef) => {\n  if (props.positions instanceof Float32Array) {\n    return /*#__PURE__*/React.createElement(PointsBuffer, _extends({}, props, {\n      ref: forwardedRef\n    }));\n  } else return /*#__PURE__*/React.createElement(PointsInstances, _extends({}, props, {\n    ref: forwardedRef\n  }));\n});\n\nexport { Point, Points, PointsBuffer, PositionPoint };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}