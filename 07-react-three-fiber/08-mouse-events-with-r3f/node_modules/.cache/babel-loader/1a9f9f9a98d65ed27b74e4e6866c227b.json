{"ast":null,"code":"import { Vector3, Line3, Plane, Triangle } from 'three';\n/**\n * Ported from: https://github.com/maurizzzio/quickhull3d/ by Mauricio Poppe (https://github.com/maurizzzio)\n */\n\nconst Visible = 0;\nconst Deleted = 1;\n\nconst _v1 = new Vector3();\n\nconst _line3 = new Line3();\n\nconst _plane = new Plane();\n\nconst _closestPoint = new Vector3();\n\nconst _triangle = new Triangle();\n\nclass ConvexHull {\n  constructor() {\n    this.tolerance = -1;\n    this.faces = []; // the generated faces of the convex hull\n\n    this.newFaces = []; // this array holds the faces that are generated within a single iteration\n    // the vertex lists work as follows:\n    //\n    // let 'a' and 'b' be 'Face' instances\n    // let 'v' be points wrapped as instance of 'Vertex'\n    //\n    //     [v, v, ..., v, v, v, ...]\n    //      ^             ^\n    //      |             |\n    //  a.outside     b.outside\n    //\n\n    this.assigned = new VertexList();\n    this.unassigned = new VertexList();\n    this.vertices = []; // vertices of the hull (internal representation of given geometry data)\n  }\n\n  setFromPoints(points) {\n    // The algorithm needs at least four points.\n    if (points.length >= 4) {\n      this.makeEmpty();\n\n      for (let i = 0, l = points.length; i < l; i++) {\n        this.vertices.push(new VertexNode(points[i]));\n      }\n\n      this.compute();\n    }\n\n    return this;\n  }\n\n  setFromObject(object) {\n    const points = [];\n    object.updateMatrixWorld(true);\n    object.traverse(function (node) {\n      const geometry = node.geometry;\n\n      if (geometry !== undefined) {\n        if (geometry.isGeometry) {\n          console.error('THREE.ConvexHull no longer supports Geometry. Use THREE.BufferGeometry instead.');\n          return;\n        } else if (geometry.isBufferGeometry) {\n          const attribute = geometry.attributes.position;\n\n          if (attribute !== undefined) {\n            for (let i = 0, l = attribute.count; i < l; i++) {\n              const point = new Vector3();\n              point.fromBufferAttribute(attribute, i).applyMatrix4(node.matrixWorld);\n              points.push(point);\n            }\n          }\n        }\n      }\n    });\n    return this.setFromPoints(points);\n  }\n\n  containsPoint(point) {\n    const faces = this.faces;\n\n    for (let i = 0, l = faces.length; i < l; i++) {\n      const face = faces[i]; // compute signed distance and check on what half space the point lies\n\n      if (face.distanceToPoint(point) > this.tolerance) return false;\n    }\n\n    return true;\n  }\n\n  intersectRay(ray, target) {\n    // based on \"Fast Ray-Convex Polyhedron Intersection\"  by Eric Haines, GRAPHICS GEMS II\n    const faces = this.faces;\n    let tNear = -Infinity;\n    let tFar = Infinity;\n\n    for (let i = 0, l = faces.length; i < l; i++) {\n      const face = faces[i]; // interpret faces as planes for the further computation\n\n      const vN = face.distanceToPoint(ray.origin);\n      const vD = face.normal.dot(ray.direction); // if the origin is on the positive side of a plane (so the plane can \"see\" the origin) and\n      // the ray is turned away or parallel to the plane, there is no intersection\n\n      if (vN > 0 && vD >= 0) return null; // compute the distance from the rayâ€™s origin to the intersection with the plane\n\n      const t = vD !== 0 ? -vN / vD : 0; // only proceed if the distance is positive. a negative distance means the intersection point\n      // lies \"behind\" the origin\n\n      if (t <= 0) continue; // now categorized plane as front-facing or back-facing\n\n      if (vD > 0) {\n        //  plane faces away from the ray, so this plane is a back-face\n        tFar = Math.min(t, tFar);\n      } else {\n        // front-face\n        tNear = Math.max(t, tNear);\n      }\n\n      if (tNear > tFar) {\n        // if tNear ever is greater than tFar, the ray must miss the convex hull\n        return null;\n      }\n    } // evaluate intersection point\n    // always try tNear first since its the closer intersection point\n\n\n    if (tNear !== -Infinity) {\n      ray.at(tNear, target);\n    } else {\n      ray.at(tFar, target);\n    }\n\n    return target;\n  }\n\n  intersectsRay(ray) {\n    return this.intersectRay(ray, _v1) !== null;\n  }\n\n  makeEmpty() {\n    this.faces = [];\n    this.vertices = [];\n    return this;\n  } // Adds a vertex to the 'assigned' list of vertices and assigns it to the given face\n\n\n  addVertexToFace(vertex, face) {\n    vertex.face = face;\n\n    if (face.outside === null) {\n      this.assigned.append(vertex);\n    } else {\n      this.assigned.insertBefore(face.outside, vertex);\n    }\n\n    face.outside = vertex;\n    return this;\n  } // Removes a vertex from the 'assigned' list of vertices and from the given face\n\n\n  removeVertexFromFace(vertex, face) {\n    if (vertex === face.outside) {\n      // fix face.outside link\n      if (vertex.next !== null && vertex.next.face === face) {\n        // face has at least 2 outside vertices, move the 'outside' reference\n        face.outside = vertex.next;\n      } else {\n        // vertex was the only outside vertex that face had\n        face.outside = null;\n      }\n    }\n\n    this.assigned.remove(vertex);\n    return this;\n  } // Removes all the visible vertices that a given face is able to see which are stored in the 'assigned' vertext list\n\n\n  removeAllVerticesFromFace(face) {\n    if (face.outside !== null) {\n      // reference to the first and last vertex of this face\n      const start = face.outside;\n      let end = face.outside;\n\n      while (end.next !== null && end.next.face === face) {\n        end = end.next;\n      }\n\n      this.assigned.removeSubList(start, end); // fix references\n\n      start.prev = end.next = null;\n      face.outside = null;\n      return start;\n    }\n  } // Removes all the visible vertices that 'face' is able to see\n\n\n  deleteFaceVertices(face, absorbingFace) {\n    const faceVertices = this.removeAllVerticesFromFace(face);\n\n    if (faceVertices !== undefined) {\n      if (absorbingFace === undefined) {\n        // mark the vertices to be reassigned to some other face\n        this.unassigned.appendChain(faceVertices);\n      } else {\n        // if there's an absorbing face try to assign as many vertices as possible to it\n        let vertex = faceVertices;\n\n        do {\n          // we need to buffer the subsequent vertex at this point because the 'vertex.next' reference\n          // will be changed by upcoming method calls\n          const nextVertex = vertex.next;\n          const distance = absorbingFace.distanceToPoint(vertex.point); // check if 'vertex' is able to see 'absorbingFace'\n\n          if (distance > this.tolerance) {\n            this.addVertexToFace(vertex, absorbingFace);\n          } else {\n            this.unassigned.append(vertex);\n          } // now assign next vertex\n\n\n          vertex = nextVertex;\n        } while (vertex !== null);\n      }\n    }\n\n    return this;\n  } // Reassigns as many vertices as possible from the unassigned list to the new faces\n\n\n  resolveUnassignedPoints(newFaces) {\n    if (this.unassigned.isEmpty() === false) {\n      let vertex = this.unassigned.first();\n\n      do {\n        // buffer 'next' reference, see .deleteFaceVertices()\n        const nextVertex = vertex.next;\n        let maxDistance = this.tolerance;\n        let maxFace = null;\n\n        for (let i = 0; i < newFaces.length; i++) {\n          const face = newFaces[i];\n\n          if (face.mark === Visible) {\n            const distance = face.distanceToPoint(vertex.point);\n\n            if (distance > maxDistance) {\n              maxDistance = distance;\n              maxFace = face;\n            }\n\n            if (maxDistance > 1000 * this.tolerance) break;\n          }\n        } // 'maxFace' can be null e.g. if there are identical vertices\n\n\n        if (maxFace !== null) {\n          this.addVertexToFace(vertex, maxFace);\n        }\n\n        vertex = nextVertex;\n      } while (vertex !== null);\n    }\n\n    return this;\n  } // Computes the extremes of a simplex which will be the initial hull\n\n\n  computeExtremes() {\n    const min = new Vector3();\n    const max = new Vector3();\n    const minVertices = [];\n    const maxVertices = []; // initially assume that the first vertex is the min/max\n\n    for (let i = 0; i < 3; i++) {\n      minVertices[i] = maxVertices[i] = this.vertices[0];\n    }\n\n    min.copy(this.vertices[0].point);\n    max.copy(this.vertices[0].point); // compute the min/max vertex on all six directions\n\n    for (let i = 0, l = this.vertices.length; i < l; i++) {\n      const vertex = this.vertices[i];\n      const point = vertex.point; // update the min coordinates\n\n      for (let j = 0; j < 3; j++) {\n        if (point.getComponent(j) < min.getComponent(j)) {\n          min.setComponent(j, point.getComponent(j));\n          minVertices[j] = vertex;\n        }\n      } // update the max coordinates\n\n\n      for (let j = 0; j < 3; j++) {\n        if (point.getComponent(j) > max.getComponent(j)) {\n          max.setComponent(j, point.getComponent(j));\n          maxVertices[j] = vertex;\n        }\n      }\n    } // use min/max vectors to compute an optimal epsilon\n\n\n    this.tolerance = 3 * Number.EPSILON * (Math.max(Math.abs(min.x), Math.abs(max.x)) + Math.max(Math.abs(min.y), Math.abs(max.y)) + Math.max(Math.abs(min.z), Math.abs(max.z)));\n    return {\n      min: minVertices,\n      max: maxVertices\n    };\n  } // Computes the initial simplex assigning to its faces all the points\n  // that are candidates to form part of the hull\n\n\n  computeInitialHull() {\n    const vertices = this.vertices;\n    const extremes = this.computeExtremes();\n    const min = extremes.min;\n    const max = extremes.max; // 1. Find the two vertices 'v0' and 'v1' with the greatest 1d separation\n    // (max.x - min.x)\n    // (max.y - min.y)\n    // (max.z - min.z)\n\n    let maxDistance = 0;\n    let index = 0;\n\n    for (let i = 0; i < 3; i++) {\n      const distance = max[i].point.getComponent(i) - min[i].point.getComponent(i);\n\n      if (distance > maxDistance) {\n        maxDistance = distance;\n        index = i;\n      }\n    }\n\n    const v0 = min[index];\n    const v1 = max[index];\n    let v2;\n    let v3; // 2. The next vertex 'v2' is the one farthest to the line formed by 'v0' and 'v1'\n\n    maxDistance = 0;\n\n    _line3.set(v0.point, v1.point);\n\n    for (let i = 0, l = this.vertices.length; i < l; i++) {\n      const vertex = vertices[i];\n\n      if (vertex !== v0 && vertex !== v1) {\n        _line3.closestPointToPoint(vertex.point, true, _closestPoint);\n\n        const distance = _closestPoint.distanceToSquared(vertex.point);\n\n        if (distance > maxDistance) {\n          maxDistance = distance;\n          v2 = vertex;\n        }\n      }\n    } // 3. The next vertex 'v3' is the one farthest to the plane 'v0', 'v1', 'v2'\n\n\n    maxDistance = -1;\n\n    _plane.setFromCoplanarPoints(v0.point, v1.point, v2.point);\n\n    for (let i = 0, l = this.vertices.length; i < l; i++) {\n      const vertex = vertices[i];\n\n      if (vertex !== v0 && vertex !== v1 && vertex !== v2) {\n        const distance = Math.abs(_plane.distanceToPoint(vertex.point));\n\n        if (distance > maxDistance) {\n          maxDistance = distance;\n          v3 = vertex;\n        }\n      }\n    }\n\n    const faces = [];\n\n    if (_plane.distanceToPoint(v3.point) < 0) {\n      // the face is not able to see the point so 'plane.normal' is pointing outside the tetrahedron\n      faces.push(Face.create(v0, v1, v2), Face.create(v3, v1, v0), Face.create(v3, v2, v1), Face.create(v3, v0, v2)); // set the twin edge\n\n      for (let i = 0; i < 3; i++) {\n        const j = (i + 1) % 3; // join face[ i ] i > 0, with the first face\n\n        faces[i + 1].getEdge(2).setTwin(faces[0].getEdge(j)); // join face[ i ] with face[ i + 1 ], 1 <= i <= 3\n\n        faces[i + 1].getEdge(1).setTwin(faces[j + 1].getEdge(0));\n      }\n    } else {\n      // the face is able to see the point so 'plane.normal' is pointing inside the tetrahedron\n      faces.push(Face.create(v0, v2, v1), Face.create(v3, v0, v1), Face.create(v3, v1, v2), Face.create(v3, v2, v0)); // set the twin edge\n\n      for (let i = 0; i < 3; i++) {\n        const j = (i + 1) % 3; // join face[ i ] i > 0, with the first face\n\n        faces[i + 1].getEdge(2).setTwin(faces[0].getEdge((3 - i) % 3)); // join face[ i ] with face[ i + 1 ]\n\n        faces[i + 1].getEdge(0).setTwin(faces[j + 1].getEdge(1));\n      }\n    } // the initial hull is the tetrahedron\n\n\n    for (let i = 0; i < 4; i++) {\n      this.faces.push(faces[i]);\n    } // initial assignment of vertices to the faces of the tetrahedron\n\n\n    for (let i = 0, l = vertices.length; i < l; i++) {\n      const vertex = vertices[i];\n\n      if (vertex !== v0 && vertex !== v1 && vertex !== v2 && vertex !== v3) {\n        maxDistance = this.tolerance;\n        let maxFace = null;\n\n        for (let j = 0; j < 4; j++) {\n          const distance = this.faces[j].distanceToPoint(vertex.point);\n\n          if (distance > maxDistance) {\n            maxDistance = distance;\n            maxFace = this.faces[j];\n          }\n        }\n\n        if (maxFace !== null) {\n          this.addVertexToFace(vertex, maxFace);\n        }\n      }\n    }\n\n    return this;\n  } // Removes inactive faces\n\n\n  reindexFaces() {\n    const activeFaces = [];\n\n    for (let i = 0; i < this.faces.length; i++) {\n      const face = this.faces[i];\n\n      if (face.mark === Visible) {\n        activeFaces.push(face);\n      }\n    }\n\n    this.faces = activeFaces;\n    return this;\n  } // Finds the next vertex to create faces with the current hull\n\n\n  nextVertexToAdd() {\n    // if the 'assigned' list of vertices is empty, no vertices are left. return with 'undefined'\n    if (this.assigned.isEmpty() === false) {\n      let eyeVertex,\n          maxDistance = 0; // grap the first available face and start with the first visible vertex of that face\n\n      const eyeFace = this.assigned.first().face;\n      let vertex = eyeFace.outside; // now calculate the farthest vertex that face can see\n\n      do {\n        const distance = eyeFace.distanceToPoint(vertex.point);\n\n        if (distance > maxDistance) {\n          maxDistance = distance;\n          eyeVertex = vertex;\n        }\n\n        vertex = vertex.next;\n      } while (vertex !== null && vertex.face === eyeFace);\n\n      return eyeVertex;\n    }\n  } // Computes a chain of half edges in CCW order called the 'horizon'.\n  // For an edge to be part of the horizon it must join a face that can see\n  // 'eyePoint' and a face that cannot see 'eyePoint'.\n\n\n  computeHorizon(eyePoint, crossEdge, face, horizon) {\n    // moves face's vertices to the 'unassigned' vertex list\n    this.deleteFaceVertices(face);\n    face.mark = Deleted;\n    let edge;\n\n    if (crossEdge === null) {\n      edge = crossEdge = face.getEdge(0);\n    } else {\n      // start from the next edge since 'crossEdge' was already analyzed\n      // (actually 'crossEdge.twin' was the edge who called this method recursively)\n      edge = crossEdge.next;\n    }\n\n    do {\n      const twinEdge = edge.twin;\n      const oppositeFace = twinEdge.face;\n\n      if (oppositeFace.mark === Visible) {\n        if (oppositeFace.distanceToPoint(eyePoint) > this.tolerance) {\n          // the opposite face can see the vertex, so proceed with next edge\n          this.computeHorizon(eyePoint, twinEdge, oppositeFace, horizon);\n        } else {\n          // the opposite face can't see the vertex, so this edge is part of the horizon\n          horizon.push(edge);\n        }\n      }\n\n      edge = edge.next;\n    } while (edge !== crossEdge);\n\n    return this;\n  } // Creates a face with the vertices 'eyeVertex.point', 'horizonEdge.tail' and 'horizonEdge.head' in CCW order\n\n\n  addAdjoiningFace(eyeVertex, horizonEdge) {\n    // all the half edges are created in ccw order thus the face is always pointing outside the hull\n    const face = Face.create(eyeVertex, horizonEdge.tail(), horizonEdge.head());\n    this.faces.push(face); // join face.getEdge( - 1 ) with the horizon's opposite edge face.getEdge( - 1 ) = face.getEdge( 2 )\n\n    face.getEdge(-1).setTwin(horizonEdge.twin);\n    return face.getEdge(0); // the half edge whose vertex is the eyeVertex\n  } //  Adds 'horizon.length' faces to the hull, each face will be linked with the\n  //  horizon opposite face and the face on the left/right\n\n\n  addNewFaces(eyeVertex, horizon) {\n    this.newFaces = [];\n    let firstSideEdge = null;\n    let previousSideEdge = null;\n\n    for (let i = 0; i < horizon.length; i++) {\n      const horizonEdge = horizon[i]; // returns the right side edge\n\n      const sideEdge = this.addAdjoiningFace(eyeVertex, horizonEdge);\n\n      if (firstSideEdge === null) {\n        firstSideEdge = sideEdge;\n      } else {\n        // joins face.getEdge( 1 ) with previousFace.getEdge( 0 )\n        sideEdge.next.setTwin(previousSideEdge);\n      }\n\n      this.newFaces.push(sideEdge.face);\n      previousSideEdge = sideEdge;\n    } // perform final join of new faces\n\n\n    firstSideEdge.next.setTwin(previousSideEdge);\n    return this;\n  } // Adds a vertex to the hull\n\n\n  addVertexToHull(eyeVertex) {\n    const horizon = [];\n    this.unassigned.clear(); // remove 'eyeVertex' from 'eyeVertex.face' so that it can't be added to the 'unassigned' vertex list\n\n    this.removeVertexFromFace(eyeVertex, eyeVertex.face);\n    this.computeHorizon(eyeVertex.point, null, eyeVertex.face, horizon);\n    this.addNewFaces(eyeVertex, horizon); // reassign 'unassigned' vertices to the new faces\n\n    this.resolveUnassignedPoints(this.newFaces);\n    return this;\n  }\n\n  cleanup() {\n    this.assigned.clear();\n    this.unassigned.clear();\n    this.newFaces = [];\n    return this;\n  }\n\n  compute() {\n    let vertex;\n    this.computeInitialHull(); // add all available vertices gradually to the hull\n\n    while ((vertex = this.nextVertexToAdd()) !== undefined) {\n      this.addVertexToHull(vertex);\n    }\n\n    this.reindexFaces();\n    this.cleanup();\n    return this;\n  }\n\n} //\n\n\nclass Face {\n  constructor() {\n    this.normal = new Vector3();\n    this.midpoint = new Vector3();\n    this.area = 0;\n    this.constant = 0; // signed distance from face to the origin\n\n    this.outside = null; // reference to a vertex in a vertex list this face can see\n\n    this.mark = Visible;\n    this.edge = null;\n  }\n\n  static create(a, b, c) {\n    const face = new Face();\n    const e0 = new HalfEdge(a, face);\n    const e1 = new HalfEdge(b, face);\n    const e2 = new HalfEdge(c, face); // join edges\n\n    e0.next = e2.prev = e1;\n    e1.next = e0.prev = e2;\n    e2.next = e1.prev = e0; // main half edge reference\n\n    face.edge = e0;\n    return face.compute();\n  }\n\n  getEdge(i) {\n    let edge = this.edge;\n\n    while (i > 0) {\n      edge = edge.next;\n      i--;\n    }\n\n    while (i < 0) {\n      edge = edge.prev;\n      i++;\n    }\n\n    return edge;\n  }\n\n  compute() {\n    const a = this.edge.tail();\n    const b = this.edge.head();\n    const c = this.edge.next.head();\n\n    _triangle.set(a.point, b.point, c.point);\n\n    _triangle.getNormal(this.normal);\n\n    _triangle.getMidpoint(this.midpoint);\n\n    this.area = _triangle.getArea();\n    this.constant = this.normal.dot(this.midpoint);\n    return this;\n  }\n\n  distanceToPoint(point) {\n    return this.normal.dot(point) - this.constant;\n  }\n\n} // Entity for a Doubly-Connected Edge List (DCEL).\n\n\nclass HalfEdge {\n  constructor(vertex, face) {\n    this.vertex = vertex;\n    this.prev = null;\n    this.next = null;\n    this.twin = null;\n    this.face = face;\n  }\n\n  head() {\n    return this.vertex;\n  }\n\n  tail() {\n    return this.prev ? this.prev.vertex : null;\n  }\n\n  length() {\n    const head = this.head();\n    const tail = this.tail();\n\n    if (tail !== null) {\n      return tail.point.distanceTo(head.point);\n    }\n\n    return -1;\n  }\n\n  lengthSquared() {\n    const head = this.head();\n    const tail = this.tail();\n\n    if (tail !== null) {\n      return tail.point.distanceToSquared(head.point);\n    }\n\n    return -1;\n  }\n\n  setTwin(edge) {\n    this.twin = edge;\n    edge.twin = this;\n    return this;\n  }\n\n} // A vertex as a double linked list node.\n\n\nclass VertexNode {\n  constructor(point) {\n    this.point = point;\n    this.prev = null;\n    this.next = null;\n    this.face = null; // the face that is able to see this vertex\n  }\n\n} // A double linked list that contains vertex nodes.\n\n\nclass VertexList {\n  constructor() {\n    this.head = null;\n    this.tail = null;\n  }\n\n  first() {\n    return this.head;\n  }\n\n  last() {\n    return this.tail;\n  }\n\n  clear() {\n    this.head = this.tail = null;\n    return this;\n  } // Inserts a vertex before the target vertex\n\n\n  insertBefore(target, vertex) {\n    vertex.prev = target.prev;\n    vertex.next = target;\n\n    if (vertex.prev === null) {\n      this.head = vertex;\n    } else {\n      vertex.prev.next = vertex;\n    }\n\n    target.prev = vertex;\n    return this;\n  } // Inserts a vertex after the target vertex\n\n\n  insertAfter(target, vertex) {\n    vertex.prev = target;\n    vertex.next = target.next;\n\n    if (vertex.next === null) {\n      this.tail = vertex;\n    } else {\n      vertex.next.prev = vertex;\n    }\n\n    target.next = vertex;\n    return this;\n  } // Appends a vertex to the end of the linked list\n\n\n  append(vertex) {\n    if (this.head === null) {\n      this.head = vertex;\n    } else {\n      this.tail.next = vertex;\n    }\n\n    vertex.prev = this.tail;\n    vertex.next = null; // the tail has no subsequent vertex\n\n    this.tail = vertex;\n    return this;\n  } // Appends a chain of vertices where 'vertex' is the head.\n\n\n  appendChain(vertex) {\n    if (this.head === null) {\n      this.head = vertex;\n    } else {\n      this.tail.next = vertex;\n    }\n\n    vertex.prev = this.tail; // ensure that the 'tail' reference points to the last vertex of the chain\n\n    while (vertex.next !== null) {\n      vertex = vertex.next;\n    }\n\n    this.tail = vertex;\n    return this;\n  } // Removes a vertex from the linked list\n\n\n  remove(vertex) {\n    if (vertex.prev === null) {\n      this.head = vertex.next;\n    } else {\n      vertex.prev.next = vertex.next;\n    }\n\n    if (vertex.next === null) {\n      this.tail = vertex.prev;\n    } else {\n      vertex.next.prev = vertex.prev;\n    }\n\n    return this;\n  } // Removes a list of vertices whose 'head' is 'a' and whose 'tail' is b\n\n\n  removeSubList(a, b) {\n    if (a.prev === null) {\n      this.head = b.next;\n    } else {\n      a.prev.next = b.next;\n    }\n\n    if (b.next === null) {\n      this.tail = a.prev;\n    } else {\n      b.next.prev = a.prev;\n    }\n\n    return this;\n  }\n\n  isEmpty() {\n    return this.head === null;\n  }\n\n}\n\nexport { ConvexHull };","map":{"version":3,"names":["Vector3","Line3","Plane","Triangle","Visible","Deleted","_v1","_line3","_plane","_closestPoint","_triangle","ConvexHull","constructor","tolerance","faces","newFaces","assigned","VertexList","unassigned","vertices","setFromPoints","points","length","makeEmpty","i","l","push","VertexNode","compute","setFromObject","object","updateMatrixWorld","traverse","node","geometry","undefined","isGeometry","console","error","isBufferGeometry","attribute","attributes","position","count","point","fromBufferAttribute","applyMatrix4","matrixWorld","containsPoint","face","distanceToPoint","intersectRay","ray","target","tNear","Infinity","tFar","vN","origin","vD","normal","dot","direction","t","Math","min","max","at","intersectsRay","addVertexToFace","vertex","outside","append","insertBefore","removeVertexFromFace","next","remove","removeAllVerticesFromFace","start","end","removeSubList","prev","deleteFaceVertices","absorbingFace","faceVertices","appendChain","nextVertex","distance","resolveUnassignedPoints","isEmpty","first","maxDistance","maxFace","mark","computeExtremes","minVertices","maxVertices","copy","j","getComponent","setComponent","Number","EPSILON","abs","x","y","z","computeInitialHull","extremes","index","v0","v1","v2","v3","set","closestPointToPoint","distanceToSquared","setFromCoplanarPoints","Face","create","getEdge","setTwin","reindexFaces","activeFaces","nextVertexToAdd","eyeVertex","eyeFace","computeHorizon","eyePoint","crossEdge","horizon","edge","twinEdge","twin","oppositeFace","addAdjoiningFace","horizonEdge","tail","head","addNewFaces","firstSideEdge","previousSideEdge","sideEdge","addVertexToHull","clear","cleanup","midpoint","area","constant","a","b","c","e0","HalfEdge","e1","e2","getNormal","getMidpoint","getArea","distanceTo","lengthSquared","last","insertAfter"],"sources":["/home/rodrigorvsn/workspace/study/threejs-journey/07-react-three-fiber/08-mouse-events-with-r3f/node_modules/three-stdlib/math/ConvexHull.js"],"sourcesContent":["import { Vector3, Line3, Plane, Triangle } from 'three';\n\n/**\n * Ported from: https://github.com/maurizzzio/quickhull3d/ by Mauricio Poppe (https://github.com/maurizzzio)\n */\n\nconst Visible = 0;\nconst Deleted = 1;\n\nconst _v1 = new Vector3();\n\nconst _line3 = new Line3();\n\nconst _plane = new Plane();\n\nconst _closestPoint = new Vector3();\n\nconst _triangle = new Triangle();\n\nclass ConvexHull {\n  constructor() {\n    this.tolerance = -1;\n    this.faces = []; // the generated faces of the convex hull\n\n    this.newFaces = []; // this array holds the faces that are generated within a single iteration\n    // the vertex lists work as follows:\n    //\n    // let 'a' and 'b' be 'Face' instances\n    // let 'v' be points wrapped as instance of 'Vertex'\n    //\n    //     [v, v, ..., v, v, v, ...]\n    //      ^             ^\n    //      |             |\n    //  a.outside     b.outside\n    //\n\n    this.assigned = new VertexList();\n    this.unassigned = new VertexList();\n    this.vertices = []; // vertices of the hull (internal representation of given geometry data)\n  }\n\n  setFromPoints(points) {\n    // The algorithm needs at least four points.\n    if (points.length >= 4) {\n      this.makeEmpty();\n\n      for (let i = 0, l = points.length; i < l; i++) {\n        this.vertices.push(new VertexNode(points[i]));\n      }\n\n      this.compute();\n    }\n\n    return this;\n  }\n\n  setFromObject(object) {\n    const points = [];\n    object.updateMatrixWorld(true);\n    object.traverse(function (node) {\n      const geometry = node.geometry;\n\n      if (geometry !== undefined) {\n        if (geometry.isGeometry) {\n          console.error('THREE.ConvexHull no longer supports Geometry. Use THREE.BufferGeometry instead.');\n          return;\n        } else if (geometry.isBufferGeometry) {\n          const attribute = geometry.attributes.position;\n\n          if (attribute !== undefined) {\n            for (let i = 0, l = attribute.count; i < l; i++) {\n              const point = new Vector3();\n              point.fromBufferAttribute(attribute, i).applyMatrix4(node.matrixWorld);\n              points.push(point);\n            }\n          }\n        }\n      }\n    });\n    return this.setFromPoints(points);\n  }\n\n  containsPoint(point) {\n    const faces = this.faces;\n\n    for (let i = 0, l = faces.length; i < l; i++) {\n      const face = faces[i]; // compute signed distance and check on what half space the point lies\n\n      if (face.distanceToPoint(point) > this.tolerance) return false;\n    }\n\n    return true;\n  }\n\n  intersectRay(ray, target) {\n    // based on \"Fast Ray-Convex Polyhedron Intersection\"  by Eric Haines, GRAPHICS GEMS II\n    const faces = this.faces;\n    let tNear = -Infinity;\n    let tFar = Infinity;\n\n    for (let i = 0, l = faces.length; i < l; i++) {\n      const face = faces[i]; // interpret faces as planes for the further computation\n\n      const vN = face.distanceToPoint(ray.origin);\n      const vD = face.normal.dot(ray.direction); // if the origin is on the positive side of a plane (so the plane can \"see\" the origin) and\n      // the ray is turned away or parallel to the plane, there is no intersection\n\n      if (vN > 0 && vD >= 0) return null; // compute the distance from the rayâ€™s origin to the intersection with the plane\n\n      const t = vD !== 0 ? -vN / vD : 0; // only proceed if the distance is positive. a negative distance means the intersection point\n      // lies \"behind\" the origin\n\n      if (t <= 0) continue; // now categorized plane as front-facing or back-facing\n\n      if (vD > 0) {\n        //  plane faces away from the ray, so this plane is a back-face\n        tFar = Math.min(t, tFar);\n      } else {\n        // front-face\n        tNear = Math.max(t, tNear);\n      }\n\n      if (tNear > tFar) {\n        // if tNear ever is greater than tFar, the ray must miss the convex hull\n        return null;\n      }\n    } // evaluate intersection point\n    // always try tNear first since its the closer intersection point\n\n\n    if (tNear !== -Infinity) {\n      ray.at(tNear, target);\n    } else {\n      ray.at(tFar, target);\n    }\n\n    return target;\n  }\n\n  intersectsRay(ray) {\n    return this.intersectRay(ray, _v1) !== null;\n  }\n\n  makeEmpty() {\n    this.faces = [];\n    this.vertices = [];\n    return this;\n  } // Adds a vertex to the 'assigned' list of vertices and assigns it to the given face\n\n\n  addVertexToFace(vertex, face) {\n    vertex.face = face;\n\n    if (face.outside === null) {\n      this.assigned.append(vertex);\n    } else {\n      this.assigned.insertBefore(face.outside, vertex);\n    }\n\n    face.outside = vertex;\n    return this;\n  } // Removes a vertex from the 'assigned' list of vertices and from the given face\n\n\n  removeVertexFromFace(vertex, face) {\n    if (vertex === face.outside) {\n      // fix face.outside link\n      if (vertex.next !== null && vertex.next.face === face) {\n        // face has at least 2 outside vertices, move the 'outside' reference\n        face.outside = vertex.next;\n      } else {\n        // vertex was the only outside vertex that face had\n        face.outside = null;\n      }\n    }\n\n    this.assigned.remove(vertex);\n    return this;\n  } // Removes all the visible vertices that a given face is able to see which are stored in the 'assigned' vertext list\n\n\n  removeAllVerticesFromFace(face) {\n    if (face.outside !== null) {\n      // reference to the first and last vertex of this face\n      const start = face.outside;\n      let end = face.outside;\n\n      while (end.next !== null && end.next.face === face) {\n        end = end.next;\n      }\n\n      this.assigned.removeSubList(start, end); // fix references\n\n      start.prev = end.next = null;\n      face.outside = null;\n      return start;\n    }\n  } // Removes all the visible vertices that 'face' is able to see\n\n\n  deleteFaceVertices(face, absorbingFace) {\n    const faceVertices = this.removeAllVerticesFromFace(face);\n\n    if (faceVertices !== undefined) {\n      if (absorbingFace === undefined) {\n        // mark the vertices to be reassigned to some other face\n        this.unassigned.appendChain(faceVertices);\n      } else {\n        // if there's an absorbing face try to assign as many vertices as possible to it\n        let vertex = faceVertices;\n\n        do {\n          // we need to buffer the subsequent vertex at this point because the 'vertex.next' reference\n          // will be changed by upcoming method calls\n          const nextVertex = vertex.next;\n          const distance = absorbingFace.distanceToPoint(vertex.point); // check if 'vertex' is able to see 'absorbingFace'\n\n          if (distance > this.tolerance) {\n            this.addVertexToFace(vertex, absorbingFace);\n          } else {\n            this.unassigned.append(vertex);\n          } // now assign next vertex\n\n\n          vertex = nextVertex;\n        } while (vertex !== null);\n      }\n    }\n\n    return this;\n  } // Reassigns as many vertices as possible from the unassigned list to the new faces\n\n\n  resolveUnassignedPoints(newFaces) {\n    if (this.unassigned.isEmpty() === false) {\n      let vertex = this.unassigned.first();\n\n      do {\n        // buffer 'next' reference, see .deleteFaceVertices()\n        const nextVertex = vertex.next;\n        let maxDistance = this.tolerance;\n        let maxFace = null;\n\n        for (let i = 0; i < newFaces.length; i++) {\n          const face = newFaces[i];\n\n          if (face.mark === Visible) {\n            const distance = face.distanceToPoint(vertex.point);\n\n            if (distance > maxDistance) {\n              maxDistance = distance;\n              maxFace = face;\n            }\n\n            if (maxDistance > 1000 * this.tolerance) break;\n          }\n        } // 'maxFace' can be null e.g. if there are identical vertices\n\n\n        if (maxFace !== null) {\n          this.addVertexToFace(vertex, maxFace);\n        }\n\n        vertex = nextVertex;\n      } while (vertex !== null);\n    }\n\n    return this;\n  } // Computes the extremes of a simplex which will be the initial hull\n\n\n  computeExtremes() {\n    const min = new Vector3();\n    const max = new Vector3();\n    const minVertices = [];\n    const maxVertices = []; // initially assume that the first vertex is the min/max\n\n    for (let i = 0; i < 3; i++) {\n      minVertices[i] = maxVertices[i] = this.vertices[0];\n    }\n\n    min.copy(this.vertices[0].point);\n    max.copy(this.vertices[0].point); // compute the min/max vertex on all six directions\n\n    for (let i = 0, l = this.vertices.length; i < l; i++) {\n      const vertex = this.vertices[i];\n      const point = vertex.point; // update the min coordinates\n\n      for (let j = 0; j < 3; j++) {\n        if (point.getComponent(j) < min.getComponent(j)) {\n          min.setComponent(j, point.getComponent(j));\n          minVertices[j] = vertex;\n        }\n      } // update the max coordinates\n\n\n      for (let j = 0; j < 3; j++) {\n        if (point.getComponent(j) > max.getComponent(j)) {\n          max.setComponent(j, point.getComponent(j));\n          maxVertices[j] = vertex;\n        }\n      }\n    } // use min/max vectors to compute an optimal epsilon\n\n\n    this.tolerance = 3 * Number.EPSILON * (Math.max(Math.abs(min.x), Math.abs(max.x)) + Math.max(Math.abs(min.y), Math.abs(max.y)) + Math.max(Math.abs(min.z), Math.abs(max.z)));\n    return {\n      min: minVertices,\n      max: maxVertices\n    };\n  } // Computes the initial simplex assigning to its faces all the points\n  // that are candidates to form part of the hull\n\n\n  computeInitialHull() {\n    const vertices = this.vertices;\n    const extremes = this.computeExtremes();\n    const min = extremes.min;\n    const max = extremes.max; // 1. Find the two vertices 'v0' and 'v1' with the greatest 1d separation\n    // (max.x - min.x)\n    // (max.y - min.y)\n    // (max.z - min.z)\n\n    let maxDistance = 0;\n    let index = 0;\n\n    for (let i = 0; i < 3; i++) {\n      const distance = max[i].point.getComponent(i) - min[i].point.getComponent(i);\n\n      if (distance > maxDistance) {\n        maxDistance = distance;\n        index = i;\n      }\n    }\n\n    const v0 = min[index];\n    const v1 = max[index];\n    let v2;\n    let v3; // 2. The next vertex 'v2' is the one farthest to the line formed by 'v0' and 'v1'\n\n    maxDistance = 0;\n\n    _line3.set(v0.point, v1.point);\n\n    for (let i = 0, l = this.vertices.length; i < l; i++) {\n      const vertex = vertices[i];\n\n      if (vertex !== v0 && vertex !== v1) {\n        _line3.closestPointToPoint(vertex.point, true, _closestPoint);\n\n        const distance = _closestPoint.distanceToSquared(vertex.point);\n\n        if (distance > maxDistance) {\n          maxDistance = distance;\n          v2 = vertex;\n        }\n      }\n    } // 3. The next vertex 'v3' is the one farthest to the plane 'v0', 'v1', 'v2'\n\n\n    maxDistance = -1;\n\n    _plane.setFromCoplanarPoints(v0.point, v1.point, v2.point);\n\n    for (let i = 0, l = this.vertices.length; i < l; i++) {\n      const vertex = vertices[i];\n\n      if (vertex !== v0 && vertex !== v1 && vertex !== v2) {\n        const distance = Math.abs(_plane.distanceToPoint(vertex.point));\n\n        if (distance > maxDistance) {\n          maxDistance = distance;\n          v3 = vertex;\n        }\n      }\n    }\n\n    const faces = [];\n\n    if (_plane.distanceToPoint(v3.point) < 0) {\n      // the face is not able to see the point so 'plane.normal' is pointing outside the tetrahedron\n      faces.push(Face.create(v0, v1, v2), Face.create(v3, v1, v0), Face.create(v3, v2, v1), Face.create(v3, v0, v2)); // set the twin edge\n\n      for (let i = 0; i < 3; i++) {\n        const j = (i + 1) % 3; // join face[ i ] i > 0, with the first face\n\n        faces[i + 1].getEdge(2).setTwin(faces[0].getEdge(j)); // join face[ i ] with face[ i + 1 ], 1 <= i <= 3\n\n        faces[i + 1].getEdge(1).setTwin(faces[j + 1].getEdge(0));\n      }\n    } else {\n      // the face is able to see the point so 'plane.normal' is pointing inside the tetrahedron\n      faces.push(Face.create(v0, v2, v1), Face.create(v3, v0, v1), Face.create(v3, v1, v2), Face.create(v3, v2, v0)); // set the twin edge\n\n      for (let i = 0; i < 3; i++) {\n        const j = (i + 1) % 3; // join face[ i ] i > 0, with the first face\n\n        faces[i + 1].getEdge(2).setTwin(faces[0].getEdge((3 - i) % 3)); // join face[ i ] with face[ i + 1 ]\n\n        faces[i + 1].getEdge(0).setTwin(faces[j + 1].getEdge(1));\n      }\n    } // the initial hull is the tetrahedron\n\n\n    for (let i = 0; i < 4; i++) {\n      this.faces.push(faces[i]);\n    } // initial assignment of vertices to the faces of the tetrahedron\n\n\n    for (let i = 0, l = vertices.length; i < l; i++) {\n      const vertex = vertices[i];\n\n      if (vertex !== v0 && vertex !== v1 && vertex !== v2 && vertex !== v3) {\n        maxDistance = this.tolerance;\n        let maxFace = null;\n\n        for (let j = 0; j < 4; j++) {\n          const distance = this.faces[j].distanceToPoint(vertex.point);\n\n          if (distance > maxDistance) {\n            maxDistance = distance;\n            maxFace = this.faces[j];\n          }\n        }\n\n        if (maxFace !== null) {\n          this.addVertexToFace(vertex, maxFace);\n        }\n      }\n    }\n\n    return this;\n  } // Removes inactive faces\n\n\n  reindexFaces() {\n    const activeFaces = [];\n\n    for (let i = 0; i < this.faces.length; i++) {\n      const face = this.faces[i];\n\n      if (face.mark === Visible) {\n        activeFaces.push(face);\n      }\n    }\n\n    this.faces = activeFaces;\n    return this;\n  } // Finds the next vertex to create faces with the current hull\n\n\n  nextVertexToAdd() {\n    // if the 'assigned' list of vertices is empty, no vertices are left. return with 'undefined'\n    if (this.assigned.isEmpty() === false) {\n      let eyeVertex,\n          maxDistance = 0; // grap the first available face and start with the first visible vertex of that face\n\n      const eyeFace = this.assigned.first().face;\n      let vertex = eyeFace.outside; // now calculate the farthest vertex that face can see\n\n      do {\n        const distance = eyeFace.distanceToPoint(vertex.point);\n\n        if (distance > maxDistance) {\n          maxDistance = distance;\n          eyeVertex = vertex;\n        }\n\n        vertex = vertex.next;\n      } while (vertex !== null && vertex.face === eyeFace);\n\n      return eyeVertex;\n    }\n  } // Computes a chain of half edges in CCW order called the 'horizon'.\n  // For an edge to be part of the horizon it must join a face that can see\n  // 'eyePoint' and a face that cannot see 'eyePoint'.\n\n\n  computeHorizon(eyePoint, crossEdge, face, horizon) {\n    // moves face's vertices to the 'unassigned' vertex list\n    this.deleteFaceVertices(face);\n    face.mark = Deleted;\n    let edge;\n\n    if (crossEdge === null) {\n      edge = crossEdge = face.getEdge(0);\n    } else {\n      // start from the next edge since 'crossEdge' was already analyzed\n      // (actually 'crossEdge.twin' was the edge who called this method recursively)\n      edge = crossEdge.next;\n    }\n\n    do {\n      const twinEdge = edge.twin;\n      const oppositeFace = twinEdge.face;\n\n      if (oppositeFace.mark === Visible) {\n        if (oppositeFace.distanceToPoint(eyePoint) > this.tolerance) {\n          // the opposite face can see the vertex, so proceed with next edge\n          this.computeHorizon(eyePoint, twinEdge, oppositeFace, horizon);\n        } else {\n          // the opposite face can't see the vertex, so this edge is part of the horizon\n          horizon.push(edge);\n        }\n      }\n\n      edge = edge.next;\n    } while (edge !== crossEdge);\n\n    return this;\n  } // Creates a face with the vertices 'eyeVertex.point', 'horizonEdge.tail' and 'horizonEdge.head' in CCW order\n\n\n  addAdjoiningFace(eyeVertex, horizonEdge) {\n    // all the half edges are created in ccw order thus the face is always pointing outside the hull\n    const face = Face.create(eyeVertex, horizonEdge.tail(), horizonEdge.head());\n    this.faces.push(face); // join face.getEdge( - 1 ) with the horizon's opposite edge face.getEdge( - 1 ) = face.getEdge( 2 )\n\n    face.getEdge(-1).setTwin(horizonEdge.twin);\n    return face.getEdge(0); // the half edge whose vertex is the eyeVertex\n  } //  Adds 'horizon.length' faces to the hull, each face will be linked with the\n  //  horizon opposite face and the face on the left/right\n\n\n  addNewFaces(eyeVertex, horizon) {\n    this.newFaces = [];\n    let firstSideEdge = null;\n    let previousSideEdge = null;\n\n    for (let i = 0; i < horizon.length; i++) {\n      const horizonEdge = horizon[i]; // returns the right side edge\n\n      const sideEdge = this.addAdjoiningFace(eyeVertex, horizonEdge);\n\n      if (firstSideEdge === null) {\n        firstSideEdge = sideEdge;\n      } else {\n        // joins face.getEdge( 1 ) with previousFace.getEdge( 0 )\n        sideEdge.next.setTwin(previousSideEdge);\n      }\n\n      this.newFaces.push(sideEdge.face);\n      previousSideEdge = sideEdge;\n    } // perform final join of new faces\n\n\n    firstSideEdge.next.setTwin(previousSideEdge);\n    return this;\n  } // Adds a vertex to the hull\n\n\n  addVertexToHull(eyeVertex) {\n    const horizon = [];\n    this.unassigned.clear(); // remove 'eyeVertex' from 'eyeVertex.face' so that it can't be added to the 'unassigned' vertex list\n\n    this.removeVertexFromFace(eyeVertex, eyeVertex.face);\n    this.computeHorizon(eyeVertex.point, null, eyeVertex.face, horizon);\n    this.addNewFaces(eyeVertex, horizon); // reassign 'unassigned' vertices to the new faces\n\n    this.resolveUnassignedPoints(this.newFaces);\n    return this;\n  }\n\n  cleanup() {\n    this.assigned.clear();\n    this.unassigned.clear();\n    this.newFaces = [];\n    return this;\n  }\n\n  compute() {\n    let vertex;\n    this.computeInitialHull(); // add all available vertices gradually to the hull\n\n    while ((vertex = this.nextVertexToAdd()) !== undefined) {\n      this.addVertexToHull(vertex);\n    }\n\n    this.reindexFaces();\n    this.cleanup();\n    return this;\n  }\n\n} //\n\n\nclass Face {\n  constructor() {\n    this.normal = new Vector3();\n    this.midpoint = new Vector3();\n    this.area = 0;\n    this.constant = 0; // signed distance from face to the origin\n\n    this.outside = null; // reference to a vertex in a vertex list this face can see\n\n    this.mark = Visible;\n    this.edge = null;\n  }\n\n  static create(a, b, c) {\n    const face = new Face();\n    const e0 = new HalfEdge(a, face);\n    const e1 = new HalfEdge(b, face);\n    const e2 = new HalfEdge(c, face); // join edges\n\n    e0.next = e2.prev = e1;\n    e1.next = e0.prev = e2;\n    e2.next = e1.prev = e0; // main half edge reference\n\n    face.edge = e0;\n    return face.compute();\n  }\n\n  getEdge(i) {\n    let edge = this.edge;\n\n    while (i > 0) {\n      edge = edge.next;\n      i--;\n    }\n\n    while (i < 0) {\n      edge = edge.prev;\n      i++;\n    }\n\n    return edge;\n  }\n\n  compute() {\n    const a = this.edge.tail();\n    const b = this.edge.head();\n    const c = this.edge.next.head();\n\n    _triangle.set(a.point, b.point, c.point);\n\n    _triangle.getNormal(this.normal);\n\n    _triangle.getMidpoint(this.midpoint);\n\n    this.area = _triangle.getArea();\n    this.constant = this.normal.dot(this.midpoint);\n    return this;\n  }\n\n  distanceToPoint(point) {\n    return this.normal.dot(point) - this.constant;\n  }\n\n} // Entity for a Doubly-Connected Edge List (DCEL).\n\n\nclass HalfEdge {\n  constructor(vertex, face) {\n    this.vertex = vertex;\n    this.prev = null;\n    this.next = null;\n    this.twin = null;\n    this.face = face;\n  }\n\n  head() {\n    return this.vertex;\n  }\n\n  tail() {\n    return this.prev ? this.prev.vertex : null;\n  }\n\n  length() {\n    const head = this.head();\n    const tail = this.tail();\n\n    if (tail !== null) {\n      return tail.point.distanceTo(head.point);\n    }\n\n    return -1;\n  }\n\n  lengthSquared() {\n    const head = this.head();\n    const tail = this.tail();\n\n    if (tail !== null) {\n      return tail.point.distanceToSquared(head.point);\n    }\n\n    return -1;\n  }\n\n  setTwin(edge) {\n    this.twin = edge;\n    edge.twin = this;\n    return this;\n  }\n\n} // A vertex as a double linked list node.\n\n\nclass VertexNode {\n  constructor(point) {\n    this.point = point;\n    this.prev = null;\n    this.next = null;\n    this.face = null; // the face that is able to see this vertex\n  }\n\n} // A double linked list that contains vertex nodes.\n\n\nclass VertexList {\n  constructor() {\n    this.head = null;\n    this.tail = null;\n  }\n\n  first() {\n    return this.head;\n  }\n\n  last() {\n    return this.tail;\n  }\n\n  clear() {\n    this.head = this.tail = null;\n    return this;\n  } // Inserts a vertex before the target vertex\n\n\n  insertBefore(target, vertex) {\n    vertex.prev = target.prev;\n    vertex.next = target;\n\n    if (vertex.prev === null) {\n      this.head = vertex;\n    } else {\n      vertex.prev.next = vertex;\n    }\n\n    target.prev = vertex;\n    return this;\n  } // Inserts a vertex after the target vertex\n\n\n  insertAfter(target, vertex) {\n    vertex.prev = target;\n    vertex.next = target.next;\n\n    if (vertex.next === null) {\n      this.tail = vertex;\n    } else {\n      vertex.next.prev = vertex;\n    }\n\n    target.next = vertex;\n    return this;\n  } // Appends a vertex to the end of the linked list\n\n\n  append(vertex) {\n    if (this.head === null) {\n      this.head = vertex;\n    } else {\n      this.tail.next = vertex;\n    }\n\n    vertex.prev = this.tail;\n    vertex.next = null; // the tail has no subsequent vertex\n\n    this.tail = vertex;\n    return this;\n  } // Appends a chain of vertices where 'vertex' is the head.\n\n\n  appendChain(vertex) {\n    if (this.head === null) {\n      this.head = vertex;\n    } else {\n      this.tail.next = vertex;\n    }\n\n    vertex.prev = this.tail; // ensure that the 'tail' reference points to the last vertex of the chain\n\n    while (vertex.next !== null) {\n      vertex = vertex.next;\n    }\n\n    this.tail = vertex;\n    return this;\n  } // Removes a vertex from the linked list\n\n\n  remove(vertex) {\n    if (vertex.prev === null) {\n      this.head = vertex.next;\n    } else {\n      vertex.prev.next = vertex.next;\n    }\n\n    if (vertex.next === null) {\n      this.tail = vertex.prev;\n    } else {\n      vertex.next.prev = vertex.prev;\n    }\n\n    return this;\n  } // Removes a list of vertices whose 'head' is 'a' and whose 'tail' is b\n\n\n  removeSubList(a, b) {\n    if (a.prev === null) {\n      this.head = b.next;\n    } else {\n      a.prev.next = b.next;\n    }\n\n    if (b.next === null) {\n      this.tail = a.prev;\n    } else {\n      b.next.prev = a.prev;\n    }\n\n    return this;\n  }\n\n  isEmpty() {\n    return this.head === null;\n  }\n\n}\n\nexport { ConvexHull };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}